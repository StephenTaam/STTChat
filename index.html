<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>STTChat</title>
<link rel="icon" type="image/png" href="imags/favicon.png">

<style>
  body{
    font-family: sans-serif;
    max-width: 860px;
    margin: 24px auto;
    padding: 0 12px;
    line-height: 1.5;
  }
  h1{ margin: 0 0 12px; }
  .row{
    display: grid;
    grid-template-columns: 1fr 260px;
    gap: 18px;
    align-items: start;
  }
  @media (max-width: 720px){
    .row{ grid-template-columns: 1fr; }
  }

  label{
    display:block;
    margin-top: 12px;
    font-weight: bold;
    font-size: 14px;
  }
  input{
    width: 100%;
    padding: 9px;
    margin-top: 6px;
    font-size: 14px;
    box-sizing: border-box;
  }
  small{ font-size: 12px; color:#666; display:block; margin-top:6px; }

  button{
    margin-top: 16px;
    padding: 10px 16px;
    font-size: 15px;
    cursor: pointer;
  }
  .btn-wide{
    width: 100%;
  }

  .card{
    border: 1px solid #ddd;
    border-radius: 10px;
    padding: 12px;
  }
  .muted{ color:#666; font-size: 12px; }
  .error{ color:#c00; font-weight:bold; }
  .success{ color:#090; font-weight:bold; }

  .pw-wrapper{ position: relative; }
  .toggle-eye{
    position:absolute;
    right: 12px;
    top: 36px;
    cursor:pointer;
    user-select:none;
    color:#666;
    font-size: 18px;
  }
  @media (max-width: 480px){
    .toggle-eye{ top: 34px; font-size: 16px; }
    button{ width:100%; font-size:16px; padding:10px; }
  }

  a{ color:#0b62d6; text-decoration: none; }
  a:hover{ text-decoration: underline; }

  /* è§†å›¾åˆ‡æ¢ */
  .hidden{ display:none; }

  /* é¦–é¡µ */
  .topbar{
    display:flex;
    justify-content: space-between;
    align-items: center;
    gap: 12px;
    margin-bottom: 10px;
  }
  .pill{
    display:inline-block;
    padding: 4px 10px;
    border-radius: 999px;
    border: 1px solid #ddd;
    font-size: 12px;
    color:#444;
  }
</style>
</head>

<body>

<!-- ========== ç™»å½•è§†å›¾ ========== -->
<div id="viewLogin">
  <h1>ç™»å½•</h1>

  <div class="row">
    <div class="card">
      <form id="loginForm">
        <label>
          ç”¨æˆ·å
          <input id="username" type="text" required autocomplete="username" />
        </label>

        <label>
          å¯†ç 
          <div class="pw-wrapper">
            <input id="password" type="password" required autocomplete="current-password" />
            <span id="togglePw" class="toggle-eye">ğŸ‘</span>
          </div>
          <small class="muted"></small>
        </label>

        <button class="btn-wide" type="submit">ç™»å½•</button>

        <p id="status" class="muted"></p>
      </form>
    </div>

    <div class="card">
      <div style="display:flex; flex-direction:column; gap:10px;">
        <div>
          <div class="muted">è¿æ¥çŠ¶æ€</div>
          <div id="wsState" class="pill">æœªè¿æ¥</div>
        </div>

        <div style="display:flex; flex-direction:column; gap:6px;">
          <a id="linkRegister" href="#">æ³¨å†Œè´¦å·</a>
        </div>

        <div class="muted">
          æ‰“å¼€é¡µé¢ä¼šè‡ªåŠ¨å»ºç«‹ wss è¿æ¥ï¼›é€€å‡ºä¼šæ–­å¼€å¹¶é‡æ–°å»ºç«‹æ–°è¿æ¥ã€‚
        </div>
      </div>
    </div>
  </div>
</div>

<!-- ========== ä¸»é¡µè§†å›¾ ========== -->
<div id="viewHome" class="hidden">
  <div class="topbar">
    <h1 style="margin:0;">ä¸»é¡µ</h1>
    <button id="btnLogout">é€€å‡º</button>
  </div>
  <img id="avatarImg"
     style="width:64px;height:64px;border-radius:50%;border:1px solid #ddd;">


  <input type="file" id="avatarFile" accept="image/*">
  <button id="btnUploadAvatar">ä¿®æ”¹å¤´åƒ</button>

  <div class="card">
    <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center;">
      <span class="pill" id="homeUser">ç”¨æˆ·ï¼š-</span>
      <span class="pill" id="homeWs">WSï¼š-</span>
      <span class="pill" id="homeKey">ç§é’¥ï¼š-</span>
    </div>

    <div style="margin-top:12px;">
      <div class="muted">
        è¯´æ˜ï¼šç§é’¥åªåœ¨å†…å­˜é‡Œï¼ˆå˜é‡é‡Œï¼‰ä¿å­˜ï¼›é€€å‡ºä¼šæ¸…ç©ºå¹¶æ–­å¼€ WSã€‚
      </div>
    </div>
  </div>
</div>

<script>
/* =====================================================
   é…ç½®ï¼šä½ éœ€è¦æ”¹è¿™é‡Œ
===================================================== */
const HTTP_BASE = "https://42.51.13.120:8080"; // â† ä½ çš„ HTTP æœåŠ¡ IP + ç«¯å£
const WS_URL = "wss://42.51.13.120:5050";     // âœ… æ”¹æˆä½ çš„ wss åœ°å€
const REGISTER_URL = "resources/signup.html";            // âœ… æ”¹æˆä½ çš„æ³¨å†Œé¡µ
/* =====================================================
   å¯†ç å­¦å‚æ•°ï¼ˆè·Ÿæ³¨å†Œé¡µä¿æŒä¸€è‡´ / æˆ–æŒ‰ä½ æœåŠ¡å™¨å®šï¼‰
===================================================== */
const PBKDF2_ITER_PWHASH = 200000;   // ç™»å½•å¯†ç å“ˆå¸Œ
const PBKDF2_ITER_KEY_DEFAULT = 200000; // è‹¥æœåŠ¡å™¨æ²¡è¿”å› iterationsï¼Œå°±ç”¨è¿™ä¸ª
const textEncoder = new TextEncoder();

/* =====================================================
   å…¨å±€çŠ¶æ€ï¼ˆåªæ”¾å†…å­˜ï¼‰
===================================================== */
let reconnectTimer = null;
let reconnectDelay = 3000; // 3 ç§’

let ws = null;
let wsReady = false;

let session = {
  username: null,
  avatarUrl : null,
  httpToken : null,

  // è§£å¯†å‡ºçš„ç§é’¥ï¼ˆåªåœ¨å†…å­˜ï¼‰
  privateKeyPkcs8Bytes: null,  // Uint8Array
  privateKeyCryptoKey: null,   // CryptoKeyï¼ˆå¯é€‰ï¼‰
  publicKeySpkiBytes: null,    // Uint8Arrayï¼ˆå¯é€‰ï¼‰

  // ä½ ä¹Ÿå¯ä»¥æ”¾ä¸€äº›â€œå·²ç™»å½•æ ‡è¯†â€ç­‰
};

/* =====================================================
   å°å·¥å…·
===================================================== */
function setStatus(msg, isErr=false){
  const el = document.getElementById("status");
  el.textContent = msg;
  el.className = isErr ? "error" : (msg ? "muted" : "muted");
  if(!msg) el.className = "muted";
}
function setWsState(text){
  const el = document.getElementById("wsState");
  el.textContent = text;
}
function strToUint8(s){ return textEncoder.encode(s); }

function base64ToBytes(b64){
  const bin = atob(b64);
  const arr = new Uint8Array(bin.length);
  for(let i=0;i<bin.length;i++) arr[i] = bin.charCodeAt(i);
  return arr;
}
function bufToBase64(buf){
  const bytes = buf instanceof ArrayBuffer ? new Uint8Array(buf) : new Uint8Array(buf.buffer || buf);
  let bin = "";
  for (let b of bytes) bin += String.fromCharCode(b);
  return btoa(bin);
}
function getRandomBytes(n){
  const arr = new Uint8Array(n);
  crypto.getRandomValues(arr);
  return arr;
}

/* =====================================================
   UIï¼šçœ¼ç›åˆ‡æ¢
===================================================== */
(function setupEye(){
  const input = document.getElementById("password");
  const eye = document.getElementById("togglePw");
  eye.addEventListener("click", ()=> {
    input.type = (input.type === "password" ? "text" : "password");
  });
})();

/* =====================================================
   é“¾æ¥
===================================================== */
document.getElementById("linkRegister").addEventListener("click", (e)=>{
  e.preventDefault();
  location.href = REGISTER_URL;
});


/* =====================================================
   WebCryptoï¼šPBKDF2 æ´¾ç”Ÿ passwordHash
   âš ï¸ ç™»å½•å¿…é¡»ç”¨â€œæœåŠ¡å™¨ç»™çš„ saltâ€ï¼Œå¦åˆ™æ¯æ¬¡éšæœº salt ä¼šå¯¼è‡´ hash æ°¸è¿œä¸åŒ
===================================================== */
async function derivePasswordHash(password, saltBytes, iterations){
  const baseKey = await crypto.subtle.importKey(
    "raw",
    strToUint8(password),
    { name:"PBKDF2" },
    false,
    ["deriveBits"]
  );

  const bits = await crypto.subtle.deriveBits(
    {
      name:"PBKDF2",
      salt: saltBytes,
      iterations,
      hash:"SHA-256"
    },
    baseKey,
    256
  );

  return new Uint8Array(bits); // 32 bytes
}

/* =====================================================
   WebCryptoï¼šå¯†ç  â†’ AES-256-GCM keyï¼ˆè§£å¯†ç§é’¥ï¼‰
===================================================== */
async function deriveAesKeyForPrivateKey(password, saltBytes, iterations){
  const baseKey = await crypto.subtle.importKey(
    "raw",
    strToUint8(password),
    { name:"PBKDF2" },
    false,
    ["deriveKey"]
  );

  return await crypto.subtle.deriveKey(
    {
      name:"PBKDF2",
      salt: saltBytes,
      iterations,
      hash:"SHA-256"
    },
    baseKey,
    { name:"AES-GCM", length:256 },
    false,
    ["decrypt"]
  );
}

async function decryptPrivateKey(aesKey, ivBytes, ciphertextBytes){
  const pkcs8 = await crypto.subtle.decrypt(
    { name:"AES-GCM", iv: ivBytes },
    aesKey,
    ciphertextBytes
  );
  return new Uint8Array(pkcs8);
}

/* å¯é€‰ï¼šæŠŠ pkcs8 ç§é’¥ bytes å¯¼å…¥æˆ CryptoKeyï¼ˆæ¯”å¦‚åç»­åš ECDH / ç­¾åç­‰ï¼‰ */
async function importPrivateKeyPkcs8(pkcs8Bytes){
  // ä½ æ³¨å†Œç”¨çš„æ˜¯ ECDH P-256ï¼ˆæ³¨æ„ï¼šWebCrypto çš„ ECDH ç§é’¥ç”¨é€”åªèƒ½ deriveKey/deriveBitsï¼‰
  return await crypto.subtle.importKey(
    "pkcs8",
    pkcs8Bytes,
    { name:"ECDH", namedCurve:"P-256" },
    false,
    ["deriveBits","deriveKey"]
  );
}

/* =====================================================
   WebSocketï¼šè¿æ¥ / é‡è¿
===================================================== */
function connectWS(){
  // é˜²æ­¢é‡å¤è¿æ¥
  if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) {
    return;
  }

  wsReady = false;
  setWsState("è¿æ¥ä¸­â€¦");

  const currentWS = new WebSocket(WS_URL);
  ws = currentWS;

  currentWS.onopen = () => {
    // é˜²æ­¢æ—§ ws å½±å“æ–° ws
    if (ws !== currentWS) return;

    wsReady = true;
    setWsState("å·²è¿æ¥");
    updateHomeBadges();

    // æˆåŠŸè¿æ¥ï¼Œæ¸…é‡è¿çŠ¶æ€
    if (reconnectTimer) {
      clearTimeout(reconnectTimer);
      reconnectTimer = null;
    }
    reconnectDelay = 3000;
  };

  currentWS.onclose = () => {
    // â­ å…³é”®ï¼šåªå¤„ç†â€œå½“å‰ wsâ€çš„ close
    if (ws !== currentWS) return;

    wsReady = false;
    ws = null;

    setWsState("å·²æ–­å¼€");
    updateHomeBadges();

    // å¦‚æœå·²ç™»å½•ï¼Œå¼ºåˆ¶å›ç™»å½•é¡µ
    if (session.username) {
      session.username = null;

      if (session.privateKeyPkcs8Bytes) {
        session.privateKeyPkcs8Bytes.fill(0);
      }
      session.privateKeyPkcs8Bytes = null;
      session.privateKeyCryptoKey = null;
      session.publicKeySpkiBytes = null;

      pendingLogin = null;

      backToLogin();
      setStatus("è¿æ¥å·²æ–­å¼€ï¼Œè¯·é‡æ–°ç™»å½•", true);
    }

    // é˜²æ­¢é‡å¤å®šæ—¶å™¨
    if (reconnectTimer) return;

    setWsState("æ–­å¼€ï¼Œé‡è¿ä¸­â€¦");

    reconnectTimer = setTimeout(() => {
      reconnectTimer = null;
      connectWS();
      reconnectDelay = Math.min(reconnectDelay * 1.5, 30000);
    }, reconnectDelay);
  };

  currentWS.onerror = () => {
    // ç»Ÿä¸€ç”± onclose å¤„ç†
  };

  currentWS.onmessage = async (ev) => {
    // é˜²æ­¢æ—§ ws æ”¶åˆ°æ¶ˆæ¯
    if (ws !== currentWS) return;

    let msg;
    try {
      msg = JSON.parse(ev.data);
    } catch {
      return;
    }

    if (msg.type === "login_challenge") {
      await handleLoginChallenge(msg);
      return;
    }

    if (msg.type === "login_result") {
      await handleLoginResult(msg);
      return;
    }

    // å…¶ä»–æ¶ˆæ¯
  };
}



function closeWS(){
  if (ws) {
    try {
      ws.close(1000, "logout");
    } catch {}
  }
  ws = null;
  wsReady = false;
}



/* =====================================================
   ç™»å½•åè®®ï¼ˆæ¨èçš„ä¸¤æ­¥ï¼‰
   Step1: client -> server: {type:"login_start", username}
   Step2: server -> client: {type:"login_challenge", salt, iterations}
   Step3: client -> server: {type:"login", username, passwordHash:{...}}
   Step4: server -> client: {type:"login_result", success, publicKey, encryptedPrivateKey, ...}
===================================================== */

let pendingLogin = null; // {username, password} ä¸´æ—¶æ”¾ä¸€ä¸‹ï¼ˆåªåœ¨æŒ‘æˆ˜æœŸé—´ç”¨ï¼‰

async function sendJson(obj){
  if (!ws || ws.readyState !== WebSocket.OPEN) {
    setStatus("WebSocket æœªè¿æ¥ï¼Œæ­£åœ¨è¿æ¥â€¦", true);
    connectWS();
    return false;
  }
  ws.send(JSON.stringify(obj));
  return true;
}


async function startLogin(username, password){
  // æŠŠå¯†ç æš‚å­˜åˆ° pendingLoginï¼Œåªç”¨ä¸€æ¬¡ï¼šç”¨äºç®— hashã€è§£å¯†ç§é’¥
  pendingLogin = { username, password };

  // å‘èµ·æŒ‘æˆ˜ï¼šè®©æœåŠ¡å™¨ç»™ saltï¼ˆå¿…é¡»ï¼‰
  const ok = await sendJson({
    type: "login_start",
    username
  });
  if(ok) setStatus("è¯·æ±‚ç™»å½•å‚æ•°ä¸­â€¦");
}

async function handleLoginChallenge(msg){
  if(!pendingLogin) return;

  const { username, password } = pendingLogin;

  // âœ… å…¼å®¹ä¸¤ç§ç»“æ„ï¼š
  // 1) {salt, iterations}
  // 2) {passwordHash:{salt, iterations}}
  const saltB64 = msg?.salt ?? msg?.passwordHash?.salt;
  const iterations = Number(msg?.iterations ?? msg?.passwordHash?.iterations ?? PBKDF2_ITER_PWHASH);

  if(!saltB64){
    setStatus("æœåŠ¡å™¨æœªè¿”å› saltï¼Œæ— æ³•ç™»å½•", true);
    pendingLogin = null;
    return;
  }

  const saltBytes = base64ToBytes(saltB64);

  setStatus("è®¡ç®—å¯†ç å“ˆå¸Œä¸­â€¦");
  const pwHashBytes = await derivePasswordHash(password, saltBytes, iterations);

  await sendJson({
    type:"login",
    username,
    passwordHash:{
      kdf:"PBKDF2-HMAC-SHA256",
      iterations,
      salt: saltB64,
      hash: bufToBase64(pwHashBytes)
    }
  });

  setStatus("å‘é€ç™»å½•è¯·æ±‚ä¸­â€¦");
}


async function handleLoginResult(msg){

  // msg æ¨èç»“æ„ï¼š
  // {
  //   type:"login_result",
  //   success:true/false,
  //   error:"...",
  //   publicKey:{alg:"ECDH",curve:"P-256",spki:"base64"},
  //   encryptedPrivateKey:{kdf:"PBKDF2-HMAC-SHA256",iterations:200000,salt:"base64",cipher:"AES-256-GCM",iv:"base64",ciphertext:"base64"}
  // }
  if(!pendingLogin){
    // ä¹Ÿå¯èƒ½æ˜¯â€œé‡å¤ç™»å½•â€ç­‰æƒ…å†µï¼›æŒ‰ä½ éœ€æ±‚å¤„ç†
  }

  if(!msg.success){
    setStatus("ç™»å½•å¤±è´¥ï¼š" + (msg.error || "æœªçŸ¥åŸå› "), true);
    pendingLogin = null;
    return;
  }

  if(!pendingLogin){
    setStatus("ç™»å½•æˆåŠŸï¼Œä½†æœ¬åœ°ç¼ºå°‘å¾…å¤„ç†å¯†ç ä¸Šä¸‹æ–‡ï¼ˆpendingLoginï¼‰", true);
    return;
  }

  const { username, password } = pendingLogin;

  // æ ¡éªŒè¿”å›å­—æ®µ
  if(!msg.encryptedPrivateKey || !msg.encryptedPrivateKey.salt || !msg.encryptedPrivateKey.iv || !msg.encryptedPrivateKey.ciphertext){
    setStatus("ç™»å½•æˆåŠŸï¼Œä½†æœåŠ¡å™¨æœªè¿”å›åŠ å¯†ç§é’¥å­—æ®µ", true);
    pendingLogin = null;
    return;
  }

  setStatus("è§£å¯†ç§é’¥ä¸­â€¦");

  const epk = msg.encryptedPrivateKey;
  const iterKey = Number(epk.iterations || PBKDF2_ITER_KEY_DEFAULT);
  const saltKeyBytes = base64ToBytes(epk.salt);
  const ivBytes = base64ToBytes(epk.iv);
  const ciphertextBytes = base64ToBytes(epk.ciphertext);

  try{
    const aesKey = await deriveAesKeyForPrivateKey(password, saltKeyBytes, iterKey);
    const pkcs8Bytes = await decryptPrivateKey(aesKey, ivBytes, ciphertextBytes);

    /// ===== ç™»å½•æˆåŠŸåï¼šå†™å…¥ sessionï¼ˆå®Œæ•´ç‰ˆï¼‰ =====
    session.avatarUrl = msg.avatar_url || "/resources/avatars/default.png";
    session.httpToken = msg.http_token || null;
    session.username = username;

    /* ---------- ç§é’¥ ---------- */
    session.privateKeyPkcs8Bytes = pkcs8Bytes;

    try {
      session.privateKeyCryptoKey = await importPrivateKeyPkcs8(pkcs8Bytes);
    } catch {
      session.privateKeyCryptoKey = null;
    }

    /* ---------- å…¬é’¥ ---------- */
    if (msg.publicKey && msg.publicKey.spki) {
      session.publicKeySpkiBytes = base64ToBytes(msg.publicKey.spki);

    try {
      session.publicKeyCryptoKey = await crypto.subtle.importKey(
      "spki",
      session.publicKeySpkiBytes,
      { name: "ECDH", namedCurve: "P-256" },
      true,
      []
    );
    } 
    catch {
      session.publicKeyCryptoKey = null;
      }
    } 
    else {
      session.publicKeySpkiBytes = null;
      session.publicKeyCryptoKey = null;
    }


    // æ¸…ç† pendingLoginï¼ˆå°½é‡å‡å°‘å¯†ç åœ¨å†…å­˜é‡Œåœç•™ï¼‰
    pendingLogin = null;

    // âš ï¸ JS å­—ç¬¦ä¸²æ— æ³•çœŸæ­£â€œæŠ¹é›¶â€ï¼Œæ‰€ä»¥åˆ«é•¿æœŸä¿å­˜ passwordï¼ˆæˆ‘ä»¬ä¹Ÿæ²¡ä¿å­˜åˆ° sessionï¼‰
    // è¿™é‡Œåªèƒ½é ä¸æŒä¹…åŒ–æ¥å‡å°‘é£é™©

    setStatus("");
    enterHome();

  }catch(err){
    console.error(err);
    setStatus("ç§é’¥è§£å¯†å¤±è´¥ï¼š" + (err.message || err), true);
    pendingLogin = null;
  }
}

/* =====================================================
   è§†å›¾åˆ‡æ¢ï¼šç™»å½• <-> ä¸»é¡µ
===================================================== */
function enterHome(){
  document.getElementById("viewLogin").classList.add("hidden");
  document.getElementById("viewHome").classList.remove("hidden");
  updateHomeBadges();
}

function backToLogin(){
  document.getElementById("viewHome").classList.add("hidden");
  document.getElementById("viewLogin").classList.remove("hidden");
  updateHomeBadges();
}

function updateHomeBadges(){
  const userEl = document.getElementById("homeUser");
  const wsEl = document.getElementById("homeWs");
  const keyEl = document.getElementById("homeKey");

  userEl.textContent = "ç”¨æˆ·ï¼š" + (session.username || "-");
  wsEl.textContent = "WSï¼š" + (wsReady ? "å·²è¿æ¥" : "æœªè¿æ¥");
  keyEl.textContent = "ç§é’¥ï¼š" + (session.privateKeyPkcs8Bytes ? "å·²åŠ è½½(å†…å­˜)" : "æ— ");
}

/* =====================================================
   è¡¨å•ï¼šæäº¤ç™»å½•
===================================================== */
document.getElementById("loginForm").addEventListener("submit", async (e)=>{
  e.preventDefault();
  setStatus("");

  const username = document.getElementById("username").value.trim();
  const password = document.getElementById("password").value;

  if(!username) return setStatus("ç”¨æˆ·åä¸èƒ½ä¸ºç©º", true);
  if(!password) return setStatus("å¯†ç ä¸èƒ½ä¸ºç©º", true);

  // æ²¡è¿æ¥å°±å…ˆè¿ï¼ˆconnectWS å†…éƒ¨ä¼šé˜²é‡å¤ï¼‰
  if(!wsReady){
    setStatus("WebSocket æœªè¿æ¥ï¼Œæ­£åœ¨è¿æ¥â€¦");
    connectWS();

    // ç»™ä¸€ç‚¹ç‚¹æ—¶é—´ï¼ˆä¸ç­‰å¾…ä¹Ÿè¡Œï¼›ç”¨æˆ·å†ç‚¹ä¸€æ¬¡ä¹Ÿèƒ½èµ°ï¼‰
    // è¿™é‡Œä¸åšå¼‚æ­¥ç­‰å¾…ï¼Œé¿å…â€œå¡ä½â€çš„é”™è§‰
  }

  // æŒ‰æ¨èåè®®èµ° challenge
  await startLogin(username, password);
});

/* =====================================================
   é€€å‡ºï¼šæ–­å¼€ ws + æ¸…å†…å­˜ + å›ç™»å½• + æ–°å»º ws
===================================================== */
document.getElementById("btnLogout").addEventListener("click", ()=>{
  // 1) ä¸»åŠ¨æ–­å¼€ WS
  closeWS();

  // 2) æ¸…ç† session
  session.username = null;
  session.publicKeySpkiBytes = null;

  if (session.privateKeyPkcs8Bytes) {
    session.privateKeyPkcs8Bytes.fill(0);
  }
  session.privateKeyPkcs8Bytes = null;
  session.privateKeyCryptoKey = null;

  pendingLogin = null;

  // 3) å›åˆ°ç™»å½•é¡µ
  backToLogin();
  setStatus("");

  // 4) å»ºç«‹ä¸€ä¸ªå…¨æ–°çš„ ws
  connectWS();
});
//è¿›å…¥ä¸»é¡µæ˜¾ç¤ºå¤´åƒ
function enterHome(){
  document.getElementById("viewLogin").classList.add("hidden");
  document.getElementById("viewHome").classList.remove("hidden");

  const path = session.avatarUrl || "/resources/avatars/default.png";
  document.getElementById("avatarImg").src = HTTP_BASE + path;

  updateHomeBadges();
}

//ä¸Šä¼ å¤´åƒ
document.getElementById("btnUploadAvatar").onclick = async ()=>{
  const f = document.getElementById("avatarFile").files[0];
  if(!f) return alert("é€‰ä¸ªå›¾ç‰‡");

  const fd = new FormData();
fd.append("file", f);

const r = await fetch(HTTP_BASE + "/api/avatar/upload", {
  method: "POST",
  headers: {
    "Authorization": "Bearer " + (session.httpToken || "")
  },
  body: fd
});




  const j = await r.json();
  if(!j.success) return alert("å¤±è´¥ï¼š" + j.error);

  session.avatarUrl = j.avatar_url;
  document.getElementById("avatarImg").src =
    j.avatar_url + "?t=" + Date.now(); // åˆ·ç¼“å­˜
};



/* =====================================================
   é¡µé¢åŠ è½½ï¼šè‡ªåŠ¨è¿æ¥ WS
===================================================== */
connectWS();
</script>

</body>
</html>
