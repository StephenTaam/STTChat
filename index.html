<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>STTChat</title>
<link rel="icon" type="image/png" href="imags/favicon.png">

<style>
  :root{
    --bg: #f4f6f8;
    --card: #ffffff;
    --card2: #f7f8fa;
    --border: #e6e9ee;
    --text: #0f172a;
    --muted: #64748b;
    --muted2: #94a3b8;
    --primary: #2a7cf7;
    --primary2:#1f6ae6;
    --danger:#ef4444;
    --danger2:#dc2626;
    --ok:#16a34a;
    --shadow: 0 18px 50px rgba(15,23,42,.10);
    --radius: 16px;
  }

  *{ box-sizing: border-box; }
  html,body{ height:100%; }
  body{
    margin:0;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "PingFang SC", "Hiragino Sans GB", "Microsoft Yahei", Arial, sans-serif;
    color: var(--text);
    background:
      radial-gradient(1000px 500px at 10% 0%, rgba(42,124,247,.10), transparent 60%),
      radial-gradient(900px 500px at 90% 10%, rgba(15,23,42,.06), transparent 65%),
      var(--bg);
  }

  .container{
    max-width: 980px;
    margin: 22px auto;
    padding: 0 14px 50px;
  }

  .brandbar{
    display:flex;
    align-items:center;
    justify-content: space-between;
    gap: 12px;
    margin-bottom: 14px;
  }
  .brand{
    display:flex;
    align-items:center;
    gap: 10px;
  }
  .logo{
    width: 38px;
    height: 38px;
    border-radius: 12px;
    background: linear-gradient(135deg, rgba(59,130,246,.9), rgba(34,197,94,.75));
    box-shadow: 0 12px 28px rgba(59,130,246,.25);
  }
  .brand h1{
    margin:0;
    font-size: 18px;
    letter-spacing: .2px;
  }
  .brand .sub{
    font-size: 12px;
    color: var(--muted);
    margin-top: 1px;
  }

  .grid{
    display:grid;
    grid-template-columns: 1.2fr .8fr;
    gap: 14px;
  }
  @media (max-width: 1024px){
    .grid{ grid-template-columns: 1fr; }
  }

  .card{
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    box-shadow: var(--shadow);
    padding: 14px;
  }
  .card.soft{
    background: var(--card2);
    box-shadow: none;
  }

  .title{
    display:flex;
    align-items:center;
    justify-content: space-between;
    gap: 10px;
    margin-bottom: 10px;
  }
  .title h2{
    margin:0;
    font-size: 15px;
    color: var(--text);
  }
  .hint{
    font-size: 12px;
    color: var(--muted);
  }

  label{
    display:block;
    margin-top: 10px;
    font-size: 12px;
    color: var(--muted);
  }
  input{
    width:100%;
    margin-top:6px;
    padding: 10px 12px;
    border-radius: 12px;
    border: 1px solid var(--border);
    background: #fff;
    color: var(--text);
    outline:none;
    transition: .15s ease;
  }
  input::placeholder{ color: rgba(255,255,255,.35); }
  input:focus{
    border-color: rgba(42,124,247,.55);
    box-shadow: 0 0 0 4px rgba(42,124,247,.12);
    background: #fff;
  }

  .row{
    display:flex;
    gap: 10px;
    align-items:center;
    flex-wrap: wrap;
  }

  .btn{
    appearance:none;
    border:none;
    border-radius: 12px;
    padding: 10px 12px;
    cursor:pointer;
    font-weight: 600;
    color: var(--text);
    background: #f3f4f6;
    border: 1px solid var(--border);
    transition: .15s ease;
    user-select:none;
  }
  .btn:hover{ transform: translateY(-1px); background: #e9edf3; }
  .btn:active{ transform: translateY(0px); }
  .btn.primary{
    background: linear-gradient(135deg, var(--primary), var(--primary2));
    border-color: rgba(42,124,247,.25);
    color: #fff;
  }
  .btn.primary:hover{ filter: brightness(1.05); }
  .btn.danger{
    background: linear-gradient(135deg, var(--danger), var(--danger2));
    border-color: rgba(239,68,68,.25);
    color: #fff;
  }
  .btn.ghost{
    background: transparent;
  }
  .btn.full{ width:100%; }

  .pill{
    display:inline-flex;
    align-items:center;
    gap: 8px;
    padding: 6px 10px;
    border-radius: 999px;
    border: 1px solid var(--border);
    background: #f8fafc;
    font-size: 12px;
    color: var(--muted);
  }
  .dot{
    width:8px;height:8px;border-radius:999px;
    background: rgba(255,255,255,0.40);
  }
  .dot.ok{ background: rgba(34,197,94,.95); }
  .dot.bad{ background: rgba(239,68,68,.95); }
  .dot.warn{ background: rgba(245,158,11,.95); }

  .muted{ color: var(--muted); font-size: 12px; line-height: 1.45; }
  .muted a{ color: rgba(147,197,253,.95); text-decoration:none; }
  .muted a:hover{ text-decoration: underline; }

  .sep{ height:1px; background: var(--border); margin: 12px 0; }

  /* Login password eye */
  .pw-wrapper{ position: relative; }
  .toggle-eye{
    position:absolute;
    right: 10px;
    top: 36px;
    cursor:pointer;
    user-select:none;
    font-size: 16px;
    opacity:.85;
  }

  /* Avatar */
  .avatar{
    width: 72px;
    height: 72px;
    border-radius: 999px;
    border: 1px solid rgba(255,255,255,0.18);
    background: rgba(255,255,255,0.06);
    object-fit: cover;
  }

  /* Toast */
  .toast-wrap{
    position: fixed;
    right: 16px;
    top: 16px;
    display:flex;
    flex-direction: column;
    gap: 10px;
    z-index: 999;
    pointer-events: none;
  }
  .toast{
    pointer-events: auto;
    min-width: 260px;
    max-width: 420px;
    padding: 10px 12px;
    border-radius: 14px;
    border: 1px solid rgba(255,255,255,0.14);
    background: rgba(14,18,35,0.90);
    box-shadow: 0 18px 60px rgba(0,0,0,.55);
    backdrop-filter: blur(10px);
    display:flex;
    gap: 10px;
    align-items:flex-start;
  }
  .toast .badge{
    width: 10px;
    height: 10px;
    border-radius: 999px;
    margin-top: 4px;
    background: rgba(255,255,255,.45);
  }
  .toast.ok .badge{ background: rgba(34,197,94,.95); }
  .toast.err .badge{ background: rgba(239,68,68,.95); }
  .toast.warn .badge{ background: rgba(245,158,11,.95); }
  .toast .msg{
    font-size: 12px;
    color: rgba(255,255,255,.86);
    line-height: 1.45;
  }
  .toast .x{
    margin-left:auto;
    cursor:pointer;
    opacity:.7;
    user-select:none;
  }
  .toast .x:hover{ opacity:1; }

  /* Collapsible */
  details{
    border: 1px solid var(--border);
    border-radius: 14px;
    padding: 10px 12px;
    background: #fff;
  }
  details summary{
    cursor:pointer;
    list-style:none;
    display:flex;
    align-items:center;
    justify-content: space-between;
    gap: 10px;
    font-weight: 700;
    font-size: 13px;
    color: var(--text);
  }
  details summary::-webkit-details-marker{ display:none; }
  details[open]{ background: #f8fafc; }
  .caret{ opacity:.7; }

  /* hidden */
  .hidden{ display:none !important; }

  /* ===== Settings Drawer ===== */
.settings{
  position: fixed;
  inset: 0;
  z-index: 1000;
}

.settings-mask{
  position:absolute;
  inset:0;
  background: rgba(0,0,0,.45);
  backdrop-filter: blur(4px);
}

.settings-panel{
  position:absolute;
  right:0;
  top:0;
  width: 420px;
  max-width: 92%;
  height:100%;
  background: #f4f7fb;
  border-left: 1px solid var(--border);
  box-shadow: -20px 0 60px rgba(15,23,42,.20);
  padding: 16px;
  overflow-y: auto;
}

.settings-header{
  display:flex;
  justify-content: space-between;
  align-items:center;
  margin-bottom: 12px;
}
/* ===== IM Layout ===== */
.im-layout{
  display:flex;
  height: min(72vh, 720px);
  min-height: 520px;
}
@media (max-width: 1024px){
  .brandbar{
    flex-direction: column;
    align-items: stretch;
    gap: 10px;
  }
  .brandbar .row{
    width: 100%;
    justify-content: space-between;
    gap: 8px;
    flex-wrap: wrap;
  }
  .im-layout{
    flex-direction: column;
    height: auto;
    min-height: 70vh;
  }
  .im-sidebar{
    width: 100%;
    min-height: 74vh;
    border-right: none;
    border-bottom: 1px solid var(--border);
  }
  .im-main{
    min-height: 70vh;
  }
  .im-list{ max-height: none; }
  #friendList{ flex: 1 1 auto; min-height: 46vh; }
  #requestList{ flex: 0 0 auto; max-height: 24vh; }
  .im-chat-header .row{
    gap: 6px;
  }
  .im-chat-input .row{
    gap: 6px;
  }
  .im-chat-input input{
    min-width: 0;
  }
  .im-chat-input{
    position: sticky;
    bottom: 0;
  }
  .im-chat-body{
    min-height: 45vh;
  }
  .im-sidebar.hidden{
    display:none;
  }
}

  .im-sidebar{
    width: 260px;
    border-right: 1px solid var(--border);
    background: #f7f8fb;
    display:flex;
    flex-direction: column;
  }

.im-sidebar-header{
  padding: 10px;
  display:flex;
  justify-content: space-between;
  align-items:center;
  font-weight:700;
}

.im-list{
  flex:1;
  overflow-y:auto;
}
#friendList{ flex: 1 1 auto; }
#requestList{ flex: 0 0 auto; max-height: 220px; }

  .im-item{
    padding: 10px;
    cursor:pointer;
    border-bottom: 1px solid var(--border);
    transition: background .15s ease, border-color .15s ease;
  }
  .im-item:hover{
    background: #eef2f7;
  }
  .im-item.active{
    background: rgba(42,124,247,.10);
    border-left: 3px solid rgba(42,124,247,.9);
  }

  .im-main{
    flex:1;
    display:flex;
    flex-direction: column;
    align-items: stretch;
    justify-content: stretch;
    background:
    radial-gradient(800px 320px at 85% 0%, rgba(42,124,247,.08), transparent 60%),
    #f8fafc;
  }

  .im-chat-header{
    padding: 12px 14px;
    border-bottom: 1px solid var(--border);
    display:flex;
    align-items:center;
    justify-content: space-between;
  }
.im-chat-title{
  font-weight: 700;
}
.im-chat-sub{
  font-size: 12px;
  color: var(--muted2);
  margin-top: 2px;
}
.im-chat-body{
  flex:1;
  overflow-y:auto;
  padding: 12px;
}
  .im-chat-input{
    border-top:1px solid var(--border);
    padding:10px;
    background: #fff;
    position: relative;
  }
.im-empty{
  flex:1;
  display:flex;
  align-items:center;
  justify-content:center;
  color: var(--muted2);
  font-size: 14px;
}
.msg{max-width:70%;padding:8px;border-radius:12px;margin:6px}
.msg.me{margin-left:auto;background:#2a7cf7;color:#fff}
.msg.peer{background:#e9edf3;color:#0f172a}
.msg img{max-width:100%;border-radius:8px}
.msg.me .muted{color: rgba(255,255,255,.88);}
.msg.peer .muted{color: #64748b;}

.emoji-panel{
  position:absolute;
  bottom:54px;
  left:10px;
  width: 320px;
  max-height: 260px;
  overflow-y:auto;
  background: rgba(12,16,28,.98);
  border: 1px solid rgba(255,255,255,.10);
  border-radius: 12px;
  box-shadow: 0 18px 50px rgba(0,0,0,.35);
  padding: 10px;
  z-index: 10;
}
.emoji-grid{
  display:grid;
  grid-template-columns: repeat(8, 1fr);
  gap: 6px;
}
.emoji-btn{
  appearance:none;
  border:none;
  background: transparent;
  cursor:pointer;
  font-size: 20px;
  line-height: 1;
  padding: 6px;
  border-radius: 8px;
}
.emoji-btn:hover{
  background: rgba(255,255,255,.08);
}

</style>
</head>

<body>
<div class="toast-wrap" id="toastWrap"></div>

<div class="container">

  <!-- ========== ç™»å½•è§†å›¾ ========== -->
  <div id="viewLogin">
    <div class="brandbar">
      <div class="brand">
        <div class="logo"></div>
        <div>
          <h1>STTChat</h1>
          <div class="sub">å®‰å…¨èŠå¤©</div>
        </div>
      </div>
      <div class="row">
        <span class="pill" title="WebSocket çŠ¶æ€">
          <span id="wsDot" class="dot bad"></span>
          <span id="wsState">æœªè¿æ¥</span>
        </span>
      </div>
    </div>

    <div class="grid">
      <div class="card">
        <div class="title">
          <h2>ç™»å½•</h2>
          <span class="hint">è¯·è¾“å…¥è´¦å·å’Œå¯†ç </span>
        </div>

        <form id="loginForm">
          <label>
            ç”¨æˆ·å
            <input id="username" type="text" required autocomplete="username" placeholder="è¾“å…¥ç”¨æˆ·å" />
          </label>

          <label>
            å¯†ç 
            <div class="pw-wrapper">
              <input id="password" type="password" required autocomplete="current-password" placeholder="è¾“å…¥å¯†ç " />
              <span id="togglePw" class="toggle-eye">ğŸ‘</span>
            </div>
            <div class="muted" style="margin-top:6px;">è¯·ç¡®ä¿è´¦å·å¯†ç æ­£ç¡®ã€‚</div>
          </label>

          <button class="btn primary full" type="submit" style="margin-top:12px;">ç™»å½•</button>

          <div id="status" class="muted" style="margin-top:10px;"></div>
        </form>
      </div>

      <div class="card soft">
        <div class="row" style="justify-content: space-between; align-items:center;">
          <div class="muted">
            æ²¡æœ‰è´¦å·ï¼Ÿ
            <a id="linkRegister" href="#">å»æ³¨å†Œ</a>
          </div>
          <button class="btn ghost" id="btnReconnect" type="button">æ‰‹åŠ¨é‡è¿ WS</button>
        </div>
      </div>
    </div>
  </div>

  <!-- ========== ä¸»é¡µè§†å›¾ ========== -->
  <!-- ========== ä¸»é¡µè§†å›¾ï¼ˆIM ä¸»ç•Œé¢ï¼‰ ========== -->
<div id="viewHome" class="hidden">

  <!-- é¡¶æ  -->
  <div class="brandbar">
    <div class="brand">
      <div class="logo"></div>
      <div>
        <h1>STTChat</h1>
        <div class="sub">ä½ çš„éšç§ï¼Œåªå±äºä½ ã€‚</div>
      </div>
    </div>

    <div class="row">
      <span class="pill" title="WebSocket çŠ¶æ€">
        <span id="wsDotHome" class="dot bad"></span>
        <span id="homeWs">WSï¼š-</span>
      </span>

      <!-- â­ æ–°å¢ï¼šè®¾ç½®æŒ‰é’® -->
      <button class="btn ghost" id="btnSettings">âš™ è®¾ç½®</button>
      <button class="btn ghost" id="btnReconnectHome" type="button">é‡è¿</button>

      <button class="btn" id="btnLogout" type="button">é€€å‡º</button>
    </div>
  </div>

  <!-- IM ä¸»åŒºåŸŸ -->
  <div class="card" style="padding:0; overflow:hidden;">
    <div class="im-layout">
  
      <!-- å·¦ä¾§ï¼šå¥½å‹ / ä¼šè¯åˆ—è¡¨ -->
      <div class="im-sidebar">
        <div class="im-sidebar-header">
          <span>å¥½å‹</span>
          <button class="btn ghost" id="btnAddFriend">ï¼‹</button>
        </div>
      
        <div id="friendList" class="im-list"></div>
      
        <div class="sep"></div>
        <div class="muted" style="padding:8px;">å¥½å‹è¯·æ±‚</div>
        <div id="requestList" class="im-list"></div>
      </div>
      
  
      <!-- å³ä¾§ï¼šèŠå¤©åŒº -->
      <div class="im-main" id="chatMain">
        <div class="im-chat-header">
          <div>
            <div class="im-chat-title" id="chatTitle">æœªé€‰æ‹©èŠå¤©</div>
            <div class="im-chat-sub" id="chatSub">è¯·é€‰æ‹©ä¸€ä¸ªå¥½å‹å¼€å§‹èŠå¤©</div>
          </div>
          <div class="row" style="gap:8px;">
            <span class="pill" id="chatState">ç§èŠ</span>
            <button class="btn ghost btn-sm hidden" id="btnCloseChat" type="button">âœ•</button>
          </div>
        </div>

        <div id="chatMessages" class="im-chat-body hidden"></div>
        <div id="chatPlaceholder" class="im-empty">è¯·é€‰æ‹©ä¸€ä¸ªå¥½å‹å¼€å§‹èŠå¤©</div>
      
        <div id="chatInputArea" class="im-chat-input hidden">
          <div class="row">
            <input id="chatInput" placeholder="è¾“å…¥æ¶ˆæ¯â€¦" style="flex:1">
            <button class="btn ghost" id="btnEmoji">ğŸ˜€</button>
            <div id="emojiPanel" class="emoji-panel hidden"></div>
            <input type="file" id="fileInput" hidden>
            <button class="btn ghost" id="btnFile">ğŸ“</button>
            <button class="btn primary" id="btnSend">å‘é€</button>
          </div>
        </div>
      </div>
      
  
    </div>
  </div>
  

</div>


</div>
<!-- ========== è®¾ç½®æŠ½å±‰ ========== -->
<div id="settingsDrawer" class="settings hidden">
  <div class="settings-mask"></div>

  <div class="settings-panel">

    <div class="settings-header">
      <h2>è®¾ç½®</h2>
      <button class="btn ghost" id="btnCloseSettings">âœ•</button>
    </div>

    <!-- ===== Profile ===== -->
    <div class="card">
      <div class="title">
        <h2>ä¸ªäººèµ„æ–™</h2>
        <span class="hint">å¤´åƒ / æ˜µç§°</span>
      </div>

      <div class="row" style="align-items: center; gap: 14px;">
        <img id="avatarImg" class="avatar" alt="avatar">
        <div style="flex:1; min-width: 220px;">
          <div class="row" style="justify-content: space-between;">
            <span class="pill" id="homeUser">ç”¨æˆ·ï¼š-</span>
        <span class="pill" id="homeKey">çŠ¶æ€ï¼š-</span>
          </div>
          <div class="muted" style="margin-top:8px;">
            é€€å‡ºä¼šæ–­å¼€è¿æ¥ã€‚
          </div>
        </div>
      </div>

      <div class="sep"></div>

      <label>
        æ˜µç§°
        <input id="displayName" type="text"
               placeholder="æ¯”å¦‚ï¼šStephenTaam" maxlength="32">
      </label>
      <div class="row" style="margin-top:10px;">
        <button class="btn primary" id="btnSaveProfile" type="button">
          ä¿å­˜æ˜µç§°
        </button>
        <span class="muted" id="profileHint"></span>
      </div>

      <div class="sep"></div>

      <label>
        ä¿®æ”¹å¤´åƒ
        <input type="file" id="avatarFile" accept="image/*">
      </label>
      <div class="row" style="margin-top:10px;">
        <button class="btn" id="btnUploadAvatar" type="button">
          ä¸Šä¼ å¤´åƒ
        </button>
        <span class="muted" id="avatarHint"></span>
      </div>
    </div>

    <!-- Right: Security + Danger -->
    <div class="card soft">
      <div class="title">
        <h2>å®‰å…¨</h2>
        <span class="hint">ä¿®æ”¹å¯†ç </span>
      </div>

      <details id="panelPassword">
        <summary>
          æ”¹å¯†ç 
          <span class="caret">â–¾</span>
        </summary>

        <div class="muted" style="margin-top:10px;">
          æç¤ºï¼š
          <ul style="margin:6px 0 0 18px; padding:0;">
            <li>è¯·ä½¿ç”¨å½“å‰å¯†ç éªŒè¯</li>
            <li>æ–°å¯†ç å°†ç«‹å³ç”Ÿæ•ˆ</li>
          </ul>
        </div>

        <label>
          æ—§å¯†ç 
          <input id="oldPw" type="password" autocomplete="current-password" placeholder="è¾“å…¥æ—§å¯†ç ">
        </label>
        <label>
          æ–°å¯†ç 
          <input id="newPw" type="password" autocomplete="new-password" placeholder="è¾“å…¥æ–°å¯†ç ï¼ˆå»ºè®® 10+ ä½ï¼‰">
        </label>
        <div class="muted" style="margin-top:6px;">
          å»ºè®®è‡³å°‘ 16 ä½ï¼ŒåŒ…å«å¤§å†™/å°å†™/æ•°å­—/ç¬¦å·ã€‚
        </div>
        <ul id="cpRules" style="margin:6px 0 0 18px; padding:0; font-size:12px; color:var(--muted);">
          <li id="cp-rule-length">âŒ é•¿åº¦è‡³å°‘ 16 ä½</li>
          <li id="cp-rule-lower">âŒ éœ€è¦å°å†™å­—æ¯</li>
          <li id="cp-rule-upper">âŒ éœ€è¦å¤§å†™å­—æ¯</li>
          <li id="cp-rule-digit">âŒ éœ€è¦æ•°å­—</li>
          <li id="cp-rule-symbol">âŒ éœ€è¦ç¬¦å·</li>
        </ul>
        <div id="cpStrength" class="muted" style="margin-top:6px;"></div>
        <label>
          ç¡®è®¤æ–°å¯†ç 
          <input id="newPw2" type="password" autocomplete="new-password" placeholder="å†æ¬¡è¾“å…¥æ–°å¯†ç ">
        </label>

        <div class="row" style="margin-top:10px;">
          <button class="btn primary" id="btnChangePassword" type="button">æäº¤æ”¹å¯†ç </button>
          <span class="muted" id="pwHint"></span>
        </div>
      </details>

      <div class="sep"></div>

      <div class="title">
        <h2>Danger Zone</h2>
        <span class="hint">ä¸å¯æ¢å¤</span>
      </div>

      <details id="panelDelete">
        <summary>
          æ³¨é”€è´¦å·ï¼ˆæ°¸ä¹…åˆ é™¤ï¼‰
          <span class="caret">â–¾</span>
        </summary>

        <div class="muted" style="margin-top:10px;">
          æ­¤æ“ä½œä¸å¯æ¢å¤ï¼Œè¯·è°¨æ…ã€‚
        </div>

        <label>
          è¾“å…¥å¯†ç ç¡®è®¤
          <input id="delPw" type="password" autocomplete="current-password" placeholder="è¾“å…¥å½“å‰å¯†ç ">
        </label>

        <label>
          äºŒæ¬¡ç¡®è®¤ï¼ˆè¾“å…¥ DELETEï¼‰
          <input id="delConfirm" type="text" placeholder="DELETE">
        </label>

        <div class="row" style="margin-top:10px;">
          <button class="btn danger" id="btnDeleteAccount" type="button">ç¡®è®¤æ³¨é”€è´¦å·</button>
          <span class="muted" id="delHint"></span>
        </div>
      </details>

      <div class="sep"></div>
      <div class="muted">
        è¿æ¥ä¿¡æ¯ï¼š
        <div class="row" style="margin-top:8px; gap:8px;">
          <span class="pill" id="pillHttp">HTTPï¼š-</span>
          <span class="pill" id="pillWs">WSï¼š-</span>
        </div>
      </div>
    </div>

  </div>
</div>


<script>
/* =====================================================
   é…ç½®ï¼šä½ éœ€è¦æ”¹è¿™é‡Œ
===================================================== */
const HTTP_BASE = "https://42.51.13.120:8080"; // â† ä½ çš„ HTTP æœåŠ¡ IP + ç«¯å£
const WS_URL = "wss://42.51.13.120:5050";     // â† ä½ çš„ wss åœ°å€
const REGISTER_URL = "resources/signup.html";  // â† ä½ çš„æ³¨å†Œé¡µ
const FILE_UPLOAD_PATH = "/api/files/upload";
/* =====================================================
   å¯†ç å­¦å‚æ•°
===================================================== */
const PBKDF2_ITER_PWHASH = 200000;     // ç™»å½• passwordHash é»˜è®¤ iterations
const PBKDF2_ITER_KEY_DEFAULT = 200000; // è‹¥æœåŠ¡å™¨æ²¡è¿”å› iterationsï¼Œå°±ç”¨è¿™ä¸ª
const MIN_PASSWORD_LENGTH = 16;
const textEncoder = new TextEncoder();

/* =====================================================
   Toast
===================================================== */
function toast(msg, type="ok", ms=3200){
  const wrap = document.getElementById("toastWrap");
  const el = document.createElement("div");
  el.className = "toast " + (type === "err" ? "err" : (type === "warn" ? "warn" : "ok"));
  el.innerHTML = `
    <div class="badge"></div>
    <div class="msg">${escapeHtml(msg)}</div>
    <div class="x">âœ•</div>
  `;
  wrap.appendChild(el);
  const rm = ()=>{ try{ el.remove(); }catch{} };
  el.querySelector(".x").onclick = rm;
  setTimeout(rm, ms);
}
function escapeHtml(s){
  return String(s).replace(/[&<>"']/g, (c)=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[c]));
}

/* =====================================================
   å…¨å±€çŠ¶æ€ï¼ˆåªæ”¾å†…å­˜ï¼‰
===================================================== */
let friendRequests = []; // [{username, display_name}]
const sessionKeys = new Map(); // peer -> CryptoKey
const pendingSendByTs = new Map(); // client ts -> pending meta

let friends = []; // [{username, display_name, avatar_url}]
let currentChat = null;

let reconnectTimer = null;
let reconnectDelay = 3000;
let ws = null;
let wsReady = false;

let session = {
  username: null,
  displayName: null,
  avatarUrl : null,
  httpToken : null,
  wsAuthed: false,
  lastLogin: null, // { username, password } kept in memory only

  // ç™»å½• challenge çš„ password hash å‚æ•°ï¼ˆåç»­æ”¹å¯†ç /æ³¨é”€ç”¨ï¼‰
  pwSaltB64: null,
  pwIterations: null,

  // è§£å¯†å‡ºçš„ç§é’¥ï¼ˆåªåœ¨å†…å­˜ï¼‰
  privateKeyPkcs8Bytes: null,  // Uint8Array
  privateKeyCryptoKey: null,   // CryptoKeyï¼ˆå¯é€‰ï¼‰
  publicKeySpkiBytes: null,    // Uint8Arrayï¼ˆå¯é€‰ï¼‰
  publicKeyCryptoKey: null
};

/* =====================================================
   å°å·¥å…·
===================================================== */
const chatInput = document.getElementById("chatInput");
const btnSend = document.getElementById("btnSend");
const btnEmoji = document.getElementById("btnEmoji");
const btnFile = document.getElementById("btnFile");
const fileInput = document.getElementById("fileInput");
const chatMessages = document.getElementById("chatMessages");
const chatPlaceholder = document.getElementById("chatPlaceholder");
const chatInputArea = document.getElementById("chatInputArea");
const chatTitle = document.getElementById("chatTitle");
const chatSub = document.getElementById("chatSub");
const btnCloseChat = document.getElementById("btnCloseChat");
const emojiPanel = document.getElementById("emojiPanel");
const imSidebar = document.querySelector(".im-sidebar");
const chatMain = document.getElementById("chatMain");
const btnReconnectHome = document.getElementById("btnReconnectHome");
const newPwInput = document.getElementById("newPw");

function isMobileView(){
  return !!(window.matchMedia && window.matchMedia("(max-width: 1024px)").matches);
}

function setMobilePane(mode){
  if(!isMobileView()) {
    if(imSidebar) imSidebar.classList.remove("hidden");
    if(chatMain) chatMain.classList.remove("hidden");
    return;
  }
  if(mode === "chat"){
    if(imSidebar) imSidebar.classList.add("hidden");
    if(chatMain) chatMain.classList.remove("hidden");
    return;
  }
  if(imSidebar) imSidebar.classList.remove("hidden");
  if(chatMain) chatMain.classList.add("hidden");
}

async function sendEncrypted(kind,data,meta={}){
 if(!currentChat || !currentChat.username) throw new Error("no current chat");
 if(!ws || ws.readyState !== WebSocket.OPEN) throw new Error("ws not connected");

 const key = await resolveSessionKey(currentChat.username);
 const iv=getRandomBytes(12);

 const ct=await crypto.subtle.encrypt({name:"AES-GCM",iv},key,data);
 const clientTs = Date.now();
 pendingSendByTs.set(String(clientTs), {
  to: currentChat.username,
  kind
 });

 ws.send(JSON.stringify({
  type:"chat_send",
  to:currentChat.username,
  ts: clientTs,
  payload:{
   kind,
   ...meta,
   iv:bufToBase64(iv),
   ciphertext:bufToBase64(ct)
  }
 }));

 // local echo so sender sees the message even if server does not echo back
 try{
  renderMessage(session.username, kind, data, meta, clientTs);
 }catch{}
}

async function resolveSessionKey(peer){
 let key=sessionKeys.get(peer);
 if(key && typeof key.then === "function"){
  key = await key;
  sessionKeys.set(peer, key);
 }
 if(!key) throw new Error("missing session key");
 if(typeof CryptoKey !== "undefined" && !(key instanceof CryptoKey)){
  throw new Error("invalid session key");
 }
 return key;
}

async function sha256Base64(bytes){
 const digest = await crypto.subtle.digest("SHA-256", bytes);
 return bufToBase64(new Uint8Array(digest));
}

async function uploadEncryptedFile(ciphertextBytes, meta){
 const headers = {
  "Content-Type": "application/json"
 };
 const body = {
  to: currentChat?.username || "",
  kind: meta.kind || "file",
  name: meta.name || "",
  mime: meta.mime || "application/octet-stream",
  size: meta.size || ciphertextBytes.byteLength,
  iv: meta.iv || "",
  hash: meta.sha256 || "",
  ciphertext: bufToBase64(ciphertextBytes)
 };
 const r = await authedFetch(FILE_UPLOAD_PATH, {
  method: "POST",
  headers,
  body: JSON.stringify(body)
 });
 const j = await readJsonSafe(r);
 if(!r.ok || !j || !j.success){
  throw new Error(j?.error || ("upload failed: http " + r.status));
 }
 return j;
}

async function sendFileReference(kind, plainBytes, meta){
 if(!currentChat || !currentChat.username) throw new Error("no current chat");
 if(!ws || ws.readyState !== WebSocket.OPEN) throw new Error("ws not connected");

 const key = await resolveSessionKey(currentChat.username);
 const iv = getRandomBytes(12);
 const ct = await crypto.subtle.encrypt({name:"AES-GCM",iv}, key, plainBytes);
 const ciphertextBytes = new Uint8Array(ct);
 const sha256 = await sha256Base64(ciphertextBytes);

 const uploadRes = await uploadEncryptedFile(ciphertextBytes, {
  ...meta,
  kind,
  iv: bufToBase64(iv),
  sha256
 });
 if(!uploadRes.file_url){
  throw new Error("upload response missing file reference");
 }

 const clientTs = Date.now();
 pendingSendByTs.set(String(clientTs), {
  to: currentChat.username,
  kind
 });

 ws.send(JSON.stringify({
  type: "chat_send",
  to: currentChat.username,
  ts: clientTs,
  payload: {
   kind,
   mime: meta.mime || "application/octet-stream",
   name: meta.name || "",
   size: meta.size || plainBytes.length || plainBytes.byteLength || 0,
   iv: bufToBase64(iv),
   file_url: uploadRes.file_url,
   hash: sha256
  }
 }));

 renderMessage(session.username, kind, plainBytes, {
  mime: meta.mime,
  name: meta.name,
  size: meta.size
 }, clientTs);
}


btnSend.onclick=async()=>{
 try{
  const text = (chatInput.value || "").trim();
  if(!text) return;
  await sendEncrypted("text",strToUint8(text),{
   mime:"text/plain",
   size:text.length
  });
  chatInput.value="";
 }catch(err){
  toast("å‘é€å¤±è´¥ï¼š" + (err.message || err), "err");
 }
};


chatInput.addEventListener("keydown", async (e)=>{
  if(e.key === "Enter"){
    e.preventDefault();
    btnSend.click();
  }
});

const EMOJIS = [
  "ğŸ˜€","ğŸ˜","ğŸ˜‚","ğŸ¤£","ğŸ˜…","ğŸ˜Š","ğŸ˜","ğŸ˜˜",
  "ğŸ˜","ğŸ¤”","ğŸ˜´","ğŸ˜®","ğŸ˜¢","ğŸ˜­","ğŸ˜¡","ğŸ¤¯",
  "ğŸ‘","ğŸ‘","ğŸ™","ğŸ‘","ğŸ”¥","âœ¨","ğŸ’¯","ğŸ‰",
  "â¤ï¸","ğŸ§¡","ğŸ’›","ğŸ’š","ğŸ’™","ğŸ’œ","ğŸ–¤","ğŸ¤",
  "ğŸ˜º","ğŸ˜¸","ğŸ˜¹","ğŸ˜»","ğŸ˜¼","ğŸ™ˆ","ğŸ™‰","ğŸ™Š",
  "â˜•","ğŸ”","ğŸŸ","ğŸ•","ğŸœ","ğŸ£","ğŸ°","ğŸ©"
];

function buildEmojiPanel(){
  if(!emojiPanel) return;
  emojiPanel.innerHTML = "";
  const grid = document.createElement("div");
  grid.className = "emoji-grid";
  for(const em of EMOJIS){
    const b = document.createElement("button");
    b.type = "button";
    b.className = "emoji-btn";
    b.textContent = em;
    b.onclick = ()=>{
      chatInput.value += em;
      chatInput.focus();
    };
    grid.appendChild(b);
  }
  emojiPanel.appendChild(grid);
}

function toggleEmojiPanel(show){
  if(!emojiPanel) return;
  if(show === undefined){
    emojiPanel.classList.toggle("hidden");
  }else{
    emojiPanel.classList.toggle("hidden", !show);
  }
}

btnEmoji.onclick = (e)=>{
  e.stopPropagation();
  buildEmojiPanel();
  toggleEmojiPanel();
};

if (btnCloseChat){
  btnCloseChat.onclick = ()=>{
    clearChatSelection();
  };
}

if(newPwInput){
  newPwInput.addEventListener("input", (e)=>{
    updateChangePwIndicators(e.target.value || "");
  });
  updateChangePwIndicators(newPwInput.value || "");
}

btnFile.onclick = ()=> fileInput.click();

document.addEventListener("click", (e)=>{
  if(!emojiPanel) return;
  if(emojiPanel.classList.contains("hidden")) return;
  if(e.target === btnEmoji || emojiPanel.contains(e.target)) return;
  toggleEmojiPanel(false);
});

fileInput.onchange=async()=>{
 const f=fileInput.files[0];
 if(!f) return;
 const buf=await f.arrayBuffer();

 try{
  await sendFileReference(
   f.type.startsWith("image") ? "image" : "file",
   new Uint8Array(buf),
   {mime: f.type || "application/octet-stream", name: f.name, size: f.size}
  );
  fileInput.value = "";
 }catch(err){
  toast("å‘é€å¤±è´¥ï¼š" + (err.message || err), "err");
 }
};

function handleChatSendAck(msg){
  const key =
    msg.client_ts !== undefined ? String(msg.client_ts) :
    (msg.ts !== undefined ? String(msg.ts) : null);

  if(msg.success){
    if(key) pendingSendByTs.delete(key);
    return;
  }

  if(key) pendingSendByTs.delete(key);
  toast("å‘é€å¤±è´¥ï¼š" + (msg.error || "unknown_error"), "err");
}


async function handleIncomingMessage(msg){
  console.log("[history] incoming", msg);
  const keyOwner = (msg.from === session.username) ? (msg.peer || currentChat?.username) : msg.from;
  if(!keyOwner) throw new Error("missing key owner");
  const key = await resolveSessionKey(keyOwner);
  console.log("[history] key resolved", keyOwner);
  let ciphertextBytes;
  if(msg.payload.ciphertext){
    ciphertextBytes = base64ToBytes(msg.payload.ciphertext);
    console.log("[history] inline ciphertext bytes", ciphertextBytes.length);
  }else{
    ciphertextBytes = await downloadEncryptedFile(msg.payload);
    console.log("[history] downloaded ciphertext bytes", ciphertextBytes.length);
  }
  const pt = await crypto.subtle.decrypt(
    {name:"AES-GCM",iv:base64ToBytes(msg.payload.iv)},
    key,
    ciphertextBytes
  );
  console.log("[history] decrypt ok", { from: msg.from, kind: msg.payload.kind });

  renderMessage(
    msg.from,
    msg.payload.kind,
    new Uint8Array(pt),
    msg.payload,
    msg.ts
  );

}

async function downloadEncryptedFile(payload){
  async function normalizeCipherBytes(rawBytes){
    if(!payload.hash) return rawBytes;
    const rawHash = await sha256Base64(rawBytes);
    if(rawHash === payload.hash) return rawBytes;

    try{
      const text = new TextDecoder().decode(rawBytes).trim();

      // JSON envelope: {"ciphertext":"base64", ...}
      if(text.startsWith("{") && text.endsWith("}")){
        const obj = JSON.parse(text);
        if(typeof obj?.ciphertext === "string"){
          const decoded = base64ToBytes(obj.ciphertext.replace(/\s+/g, ""));
          const decodedHash = await sha256Base64(decoded);
          if(!payload.hash || decodedHash === payload.hash) return decoded;
        }
      }

      // Plain base64 text
      if(/^[A-Za-z0-9+/=\r\n]+$/.test(text)){
        const decoded = base64ToBytes(text.replace(/\s+/g, ""));
        const decodedHash = await sha256Base64(decoded);
        if(decodedHash === payload.hash) return decoded;
      }
    }catch{}

    throw new Error("ciphertext hash mismatch");
  }

  if(!payload.file_url) throw new Error("missing file_url");

  const url = payload.file_url.startsWith("/") ? (HTTP_BASE + payload.file_url) : payload.file_url;
  const r = await fetch(url);
  if(!r.ok) throw new Error("download failed: http " + r.status);
  const rawBytes = new Uint8Array(await r.arrayBuffer());
  return await normalizeCipherBytes(rawBytes);
}

function renderMessage(from,kind,data,meta,ts){
 console.log("[render] message", { from, kind, size: data?.length || 0, ts });
 const div=document.createElement("div");
 div.className="msg "+(from===session.username?"me":"peer");

 const time = (ts !== undefined && ts !== null)
   ? new Date(Number(ts))
   : null;

 if(kind==="text"){
  div.textContent=new TextDecoder().decode(data);
 }

 if(kind==="image"){
  const url=URL.createObjectURL(new Blob([data],{type:meta.mime}));
  div.innerHTML=`<img src="${url}">`;
 }

 if(kind==="file"){
  const url=URL.createObjectURL(new Blob([data],{type:meta.mime}));
  div.innerHTML=`<a href="${url}" download="${meta.name}">ğŸ“ ${meta.name}</a>`;
 }

 if(time && !isNaN(time.getTime())){
  const t = document.createElement("div");
  t.className = "muted";
  t.style.marginTop = "4px";
  t.textContent = time.toLocaleString();
  div.appendChild(t);
 }

 chatMessages.appendChild(div);
 chatMessages.scrollTop=chatMessages.scrollHeight;
}

async function loadHistory(peer){
 try{
  console.log("[history] load start", { peer });
  const r = await authedFetch(`/api/messages?peer=${encodeURIComponent(peer)}`);
  const j = await readJsonSafe(r);
  console.log("[history] response", { status: r.status, body: j });
  if(!r.ok || !j || !j.success){
    toast("å†å²æ¶ˆæ¯åŠ è½½å¤±è´¥ï¼š" + (j?.error || ("HTTP " + r.status)), "err");
    return;
  }
  const list = Array.isArray(j.messages) ? j.messages : (Array.isArray(j.message) ? j.message : []);
  list.sort((a,b)=>{
    const at = Number((a && a.payload && a.payload.ts) ? a.payload.ts : a?.ts || 0);
    const bt = Number((b && b.payload && b.payload.ts) ? b.payload.ts : b?.ts || 0);
    return at - bt;
  });
  console.log("[history] list length", list.length);
  for(const m of list){
    const payload = (m && m.payload && m.payload.payload) ? m.payload.payload : m.payload;
    const ts = (m && m.payload && m.payload.ts) ? m.payload.ts : m.ts;
    const from = (m && m.payload && m.payload.from) ? m.payload.from : m.from;
    console.log("[history] normalized", { from, ts, hasPayload: !!payload });
    if(!from || !payload) continue;
    await handleIncomingMessage({
      from,
      payload,
      ts,
      peer
    });
  }
  console.log("[history] load done");
 }catch(err){
  console.error("[history] load exception", err);
  toast("å†å²æ¶ˆæ¯åŠ è½½å¤±è´¥", "err");
 }
}

async function fetchPasswordParams(){
  if(!session.httpToken) throw new Error("no http token");

  const r = await fetch(HTTP_BASE + "/api/user/password_params", {
    method: "GET",
    headers: {
      "Authorization": "Bearer " + session.httpToken
    }
  });

  if(!r.ok) throw new Error("http " + r.status);

  const j = await r.json();
  if(!j.success || !j.passwordHash)
    throw new Error("invalid response");

  return j.passwordHash; 
  // { kdf, iterations, salt }
}

function $(id){ return document.getElementById(id); }

function setStatus(msg, isErr=false){
  const el = $("status");
  el.textContent = msg;
  el.style.color = isErr ? "rgba(239,68,68,.95)" : "rgba(255,255,255,.70)";
}

function setWsState(text){
  $("wsState").textContent = text;
}

function updateWsDot(){
  const dot1 = $("wsDot");
  const dot2 = $("wsDotHome");
  const ok = wsReady;
  if(dot1){
    dot1.className = "dot " + (ok ? "ok" : "bad");
  }
  if(dot2){
    dot2.className = "dot " + (ok ? "ok" : "bad");
  }
}

function strToUint8(s){ return textEncoder.encode(s); }

function base64ToBytes(b64){
  const bin = atob(b64);
  const arr = new Uint8Array(bin.length);
  for(let i=0;i<bin.length;i++) arr[i] = bin.charCodeAt(i);
  return arr;
}
function bufToBase64(buf){
  const bytes = buf instanceof ArrayBuffer ? new Uint8Array(buf) : new Uint8Array(buf.buffer || buf);
  let bin = "";
  for (let b of bytes) bin += String.fromCharCode(b);
  return btoa(bin);
}
function getRandomBytes(n){
  const arr = new Uint8Array(n);
  crypto.getRandomValues(arr);
  return arr;
}

function updateChangePwIndicators(pw){
  const ruleLength = document.getElementById("cp-rule-length");
  const ruleLower = document.getElementById("cp-rule-lower");
  const ruleUpper = document.getElementById("cp-rule-upper");
  const ruleDigit = document.getElementById("cp-rule-digit");
  const ruleSymbol = document.getElementById("cp-rule-symbol");
  const strength = document.getElementById("cpStrength");

  const hasLower = /[a-z]/.test(pw);
  const hasUpper = /[A-Z]/.test(pw);
  const hasDigit = /[0-9]/.test(pw);
  const hasSymbol = /[^\w\s]/.test(pw);
  const longEnough = pw.length >= MIN_PASSWORD_LENGTH;

  if(ruleLength) ruleLength.textContent = (longEnough ? "âœ…" : "âŒ") + " é•¿åº¦è‡³å°‘ 16 ä½";
  if(ruleLower) ruleLower.textContent = (hasLower ? "âœ…" : "âŒ") + " éœ€è¦å°å†™å­—æ¯";
  if(ruleUpper) ruleUpper.textContent = (hasUpper ? "âœ…" : "âŒ") + " éœ€è¦å¤§å†™å­—æ¯";
  if(ruleDigit) ruleDigit.textContent = (hasDigit ? "âœ…" : "âŒ") + " éœ€è¦æ•°å­—";
  if(ruleSymbol) ruleSymbol.textContent = (hasSymbol ? "âœ…" : "âŒ") + " éœ€è¦ç¬¦å·";

  const score = [longEnough, hasLower, hasUpper, hasDigit, hasSymbol].filter(Boolean).length;
  const levels = ["å¾ˆå¼±","å¼±","ä¸€èˆ¬","å¼º","å¾ˆå¼º"];
  if(strength){
    strength.textContent = "å¯†ç å¼ºåº¦ï¼š" + levels[Math.min(score,4)];
  }
}

function isStrongPassword(pw){
  return pw.length >= MIN_PASSWORD_LENGTH
    && /[a-z]/.test(pw)
    && /[A-Z]/.test(pw)
    && /[0-9]/.test(pw)
    && /[^\w\s]/.test(pw);
}

/* =====================================================
   UIï¼šçœ¼ç›åˆ‡æ¢
===================================================== */
(function setupEye(){
  const input = $("password");
  const eye = $("togglePw");
  eye.addEventListener("click", ()=> {
    input.type = (input.type === "password" ? "text" : "password");
  });
})();

/* =====================================================
   é“¾æ¥
===================================================== */
$("linkRegister").addEventListener("click", (e)=>{
  e.preventDefault();
  location.href = REGISTER_URL;
});
$("btnReconnect").addEventListener("click", ()=>{
  toast("æ­£åœ¨æ‰‹åŠ¨é‡è¿ WSâ€¦", "warn");
  try{ if(ws) ws.close(4000, "manual reconnect"); }catch{}
  ws = null;
  wsReady = false;
  connectWS();
});
if(btnReconnectHome){
  btnReconnectHome.addEventListener("click", ()=>{
    toast("æ­£åœ¨æ‰‹åŠ¨é‡è¿ WSâ€¦", "warn");
    try{ if(ws) ws.close(4000, "manual reconnect"); }catch{}
    ws = null;
    wsReady = false;
    connectWS();
  });
}

/* =====================================================
   WebCryptoï¼šPBKDF2 æ´¾ç”Ÿ passwordHash
===================================================== */
async function derivePasswordHash(password, saltBytes, iterations){
  const baseKey = await crypto.subtle.importKey(
    "raw",
    strToUint8(password),
    { name:"PBKDF2" },
    false,
    ["deriveBits"]
  );

  const bits = await crypto.subtle.deriveBits(
    { name:"PBKDF2", salt: saltBytes, iterations, hash:"SHA-256" },
    baseKey,
    256
  );
  return new Uint8Array(bits); // 32 bytes
}

/* å¯†ç  â†’ AES-256-GCM keyï¼ˆè§£å¯†/åŠ å¯†ç§é’¥ï¼‰ */
async function deriveAesKey(password, saltBytes, iterations, usage){
  const baseKey = await crypto.subtle.importKey(
    "raw",
    strToUint8(password),
    { name:"PBKDF2" },
    false,
    ["deriveKey"]
  );
  return await crypto.subtle.deriveKey(
    { name:"PBKDF2", salt: saltBytes, iterations, hash:"SHA-256" },
    baseKey,
    { name:"AES-GCM", length:256 },
    false,
    usage
  );
}

async function decryptPrivateKey(aesKey, ivBytes, ciphertextBytes){
  const pkcs8 = await crypto.subtle.decrypt(
    { name:"AES-GCM", iv: ivBytes },
    aesKey,
    ciphertextBytes
  );
  return new Uint8Array(pkcs8);
}

async function encryptPrivateKey(aesKey, ivBytes, plainBytes){
  const ct = await crypto.subtle.encrypt(
    { name:"AES-GCM", iv: ivBytes },
    aesKey,
    plainBytes
  );
  return new Uint8Array(ct);
}

async function importPrivateKeyPkcs8(pkcs8Bytes){
  return await crypto.subtle.importKey(
    "pkcs8",
    pkcs8Bytes,
    { name:"ECDH", namedCurve:"P-256" },
    false,
    ["deriveBits","deriveKey"]
  );
}

/* =====================================================
   WebSocketï¼šè¿æ¥ / é‡è¿
===================================================== */
function connectWS(){
  if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) {
    return;
  }

  wsReady = false;
  setWsState("è¿æ¥ä¸­â€¦");
  updateWsDot();

  const currentWS = new WebSocket(WS_URL);
  ws = currentWS;

  currentWS.onopen = () => {
    if (ws !== currentWS) return;
    wsReady = true;
    setWsState("å·²è¿æ¥");
    updateWsDot();
    updateHomeBadges();
    updateConnPills();

    if (reconnectTimer) { clearTimeout(reconnectTimer); reconnectTimer = null; }
    reconnectDelay = 3000;

    // try auto re-login if we have credentials in memory
    if (session.lastLogin && !session.wsAuthed) {
      startLogin(session.lastLogin.username, session.lastLogin.password);
    }
  };

  currentWS.onclose = () => {
    if (ws !== currentWS) return;

    wsReady = false;
    ws = null;

    setWsState("å·²æ–­å¼€");
    updateWsDot();
    updateHomeBadges();
    updateConnPills();

    if (session.username) {
      // æ–­çº¿ä¸å¼ºåˆ¶ç™»å‡ºï¼Œç­‰å¾…é‡è¿
      session.wsAuthed = false;
      setStatus("è¿æ¥å·²æ–­å¼€ï¼Œæ­£åœ¨é‡è¿â€¦", true);
      toast("WS æ–­å¼€ï¼šæ­£åœ¨é‡è¿", "warn");
    }

    if (reconnectTimer) return;

    setWsState("æ–­å¼€ï¼Œé‡è¿ä¸­â€¦");
    updateWsDot();

    reconnectTimer = setTimeout(() => {
      reconnectTimer = null;
      connectWS();
      reconnectDelay = Math.min(reconnectDelay * 1.5, 30000);
    }, reconnectDelay);
  };

  currentWS.onerror = () => { /* ç»Ÿä¸€ç”± onclose å¤„ç† */ };

  currentWS.onmessage = async (ev) => {
    if (ws !== currentWS) return;

    console.log("[ws] raw", ev.data);
    let msg;
    try { msg = JSON.parse(ev.data); } catch { return; }
    console.log("[ws] parsed", msg);

    if (msg.type === "login_challenge") {
      await handleLoginChallenge(msg);
      return;
    }
    if (msg.type === "login_result") {
      await handleLoginResult(msg);
      return;
    }
    if (msg.type === "chat_send") {
      handleChatSendAck(msg);
      return;
    }
    if (msg.type === "friend_accepted") {
      await handleFriendAccepted(msg);
      return;
    }
    if (msg.type === "friend_removed") {
      handleFriendRemoved(msg);
      return;
    }
    if (msg.type === "friends_refresh") {
      await loadFriends();
      return;
    }
    // å…¶ä»–æ¶ˆæ¯
    if (msg.type === "chat_recv") {
      if (msg.from === session.username) {
        const key = (msg.client_ts !== undefined && msg.client_ts !== null)
      ? String(msg.client_ts)
      : (msg.ts !== undefined && msg.ts !== null ? String(msg.ts) : null);
    if (key && pendingSendByTs.has(key)) {
      pendingSendByTs.delete(key);
      return;
    }
  }
  handleIncomingMessage(msg);
}
if (msg.type === "friend_request") {
  toast("æ”¶åˆ°å¥½å‹è¯·æ±‚", "warn");
  await loadFriends();
}

  };
}

function closeWS(){
  if (ws) {
    try { ws.close(1000, "logout"); } catch {}
  }
  ws = null;
  wsReady = false;
  updateWsDot();
}

/* =====================================================
   ç™»å½•åè®®ï¼ˆä¸¤æ­¥ï¼‰
===================================================== */
let pendingLogin = null; // {username, password}

async function sendJson(obj){
  if (!ws || ws.readyState !== WebSocket.OPEN) {
    setStatus("WebSocket æœªè¿æ¥ï¼Œæ­£åœ¨è¿æ¥â€¦", true);
    connectWS();
    return false;
  }
  ws.send(JSON.stringify(obj));
  return true;
}

async function startLogin(username, password){
  pendingLogin = { username, password };

  const ok = await sendJson({ type:"login_start", username });
  if(ok) setStatus("è¯·æ±‚ç™»å½•å‚æ•°ä¸­â€¦");
}

async function handleLoginChallenge(msg){
  if(!pendingLogin) return;

  const { username, password } = pendingLogin;

  const saltB64 = msg?.salt ?? msg?.passwordHash?.salt;
  const iterations = Number(msg?.iterations ?? msg?.passwordHash?.iterations ?? PBKDF2_ITER_PWHASH);

  if(!saltB64){
    setStatus("æœåŠ¡å™¨æœªè¿”å› saltï¼Œæ— æ³•ç™»å½•", true);
    pendingLogin = null;
    toast("æœåŠ¡å™¨æœªè¿”å› salt", "err");
    return;
  }

  // ä¿å­˜ challenge å‚æ•°ï¼ˆåç»­æ”¹å¯†ç /æ³¨é”€ç”¨ï¼‰
  session.pwSaltB64 = saltB64;
  session.pwIterations = iterations;

  const saltBytes = base64ToBytes(saltB64);

  setStatus("è®¡ç®—å¯†ç å“ˆå¸Œä¸­â€¦");
  const pwHashBytes = await derivePasswordHash(password, saltBytes, iterations);

  await sendJson({
    type:"login",
    username,
    passwordHash:{
      kdf:"PBKDF2-HMAC-SHA256",
      iterations,
      salt: saltB64,
      hash: bufToBase64(pwHashBytes)
    }
  });

  setStatus("å‘é€ç™»å½•è¯·æ±‚ä¸­â€¦");
}

async function handleLoginResult(msg){
  if(!msg.success){
    setStatus("ç™»å½•å¤±è´¥ï¼š" + (msg.error || "æœªçŸ¥åŸå› "), true);
    toast("ç™»å½•å¤±è´¥ï¼š" + (msg.error || "æœªçŸ¥åŸå› "), "err");
    pendingLogin = null;
    return;
  }

  if(!pendingLogin){
    setStatus("ç™»å½•æˆåŠŸï¼Œä½†æœ¬åœ°ç¼ºå°‘ pendingLoginï¼ˆå¯†ç ä¸Šä¸‹æ–‡ï¼‰", true);
    toast("ç™»å½•æˆåŠŸä½†ç¼ºå°‘ pendingLogin", "warn");
    return;
  }

  const { username, password } = pendingLogin;

  if(!msg.encryptedPrivateKey || !msg.encryptedPrivateKey.salt || !msg.encryptedPrivateKey.iv || !msg.encryptedPrivateKey.ciphertext){
    setStatus("ç™»å½•æˆåŠŸï¼Œä½†æœåŠ¡å™¨æœªè¿”å›åŠ å¯†ç§é’¥å­—æ®µ", true);
    toast("ç¼ºå°‘ encryptedPrivateKey", "err");
    pendingLogin = null;
    return;
  }

  setStatus("è§£å¯†ç§é’¥ä¸­â€¦");

  const epk = msg.encryptedPrivateKey;
  const iterKey = Number(epk.iterations || PBKDF2_ITER_KEY_DEFAULT);
  const saltKeyBytes = base64ToBytes(epk.salt);
  const ivBytes = base64ToBytes(epk.iv);
  const ciphertextBytes = base64ToBytes(epk.ciphertext);

  try{
    const aesKey = await deriveAesKey(password, saltKeyBytes, iterKey, ["decrypt"]);
    const pkcs8Bytes = await decryptPrivateKey(aesKey, ivBytes, ciphertextBytes);

    // ===== ç™»å½•æˆåŠŸåï¼šå†™å…¥ session =====
    session.username = username;
    session.httpToken = msg.http_token || null;
    session.avatarUrl = msg.avatar_url || "/resources/avatars/default.png";
    session.displayName = msg.display_name || msg.displayName || "";
    session.wsAuthed = true;
    session.lastLogin = { username, password };

    session.privateKeyPkcs8Bytes = pkcs8Bytes;

    try { session.privateKeyCryptoKey = await importPrivateKeyPkcs8(pkcs8Bytes); }
    catch { session.privateKeyCryptoKey = null; }

    if (msg.publicKey && msg.publicKey.spki) {
      session.publicKeySpkiBytes = base64ToBytes(msg.publicKey.spki);
      try {
        session.publicKeyCryptoKey = await crypto.subtle.importKey(
          "spki",
          session.publicKeySpkiBytes,
          { name: "ECDH", namedCurve: "P-256" },
          true,
          []
        );
      } catch { session.publicKeyCryptoKey = null; }
    } else {
      session.publicKeySpkiBytes = null;
      session.publicKeyCryptoKey = null;
    }

    pendingLogin = null;
    setStatus("");
    toast("ç™»å½•æˆåŠŸ", "ok");
    enterHome();

  }catch(err){
    console.error(err);
    setStatus("ç§é’¥è§£å¯†å¤±è´¥ï¼š" + (err.message || err), true);
    toast("ç§é’¥è§£å¯†å¤±è´¥", "err");
    pendingLogin = null;
  }
}

/* =====================================================
   è§†å›¾åˆ‡æ¢
===================================================== */
function backToLogin(){
  $("viewHome").classList.add("hidden");
  $("viewLogin").classList.remove("hidden");
  clearChatSelection();
  updateHomeBadges();
  updateConnPills();
}

function enterHome(){
  $("viewLogin").classList.add("hidden");
  $("viewHome").classList.remove("hidden");

  const path = session.avatarUrl || "/resources/avatars/default.png";
  $("avatarImg").src = HTTP_BASE + path;

  $("displayName").value = session.displayName || "";

  updateHomeBadges();
  updateConnPills();
  loadFriends();
  clearChatSelection();
  setMobilePane("list");

}

function updateHomeBadges(){
  if($("homeUser")) $("homeUser").textContent = "ç”¨æˆ·ï¼š" + (session.username || "-");
  if($("homeWs")) $("homeWs").textContent = "WSï¼š" + (wsReady ? "å·²è¿æ¥" : "æœªè¿æ¥");
  if($("homeKey")) $("homeKey").textContent = "çŠ¶æ€ï¼š" + (session.privateKeyPkcs8Bytes ? "å¯ç”¨" : "æœªå°±ç»ª");
  updateWsDot();
}

function updateConnPills(){
  if($("pillHttp")) $("pillHttp").textContent = "HTTPï¼š" + (session.httpToken ? "å·²ç™»å½•(token)" : "-");
  if($("pillWs")) $("pillWs").textContent = "WSï¼š" + (wsReady ? "å·²è¿æ¥" : "æœªè¿æ¥");
}

/* æ¸…ç†æ•æ„Ÿå†…å­˜ */
function wipeSensitiveMemory(){
  session.username = null;
  session.displayName = null;
  session.avatarUrl = null;
  session.httpToken = null;

  session.pwSaltB64 = null;
  session.pwIterations = null;

  session.publicKeySpkiBytes = null;
  session.publicKeyCryptoKey = null;

  if (session.privateKeyPkcs8Bytes) {
    try { session.privateKeyPkcs8Bytes.fill(0); } catch {}
  }
  session.privateKeyPkcs8Bytes = null;
  session.privateKeyCryptoKey = null;
}

/* =====================================================
   ç™»å½•è¡¨å•
===================================================== */
$("loginForm").addEventListener("submit", async (e)=>{
  e.preventDefault();
  setStatus("");

  const username = $("username").value.trim();
  const password = $("password").value;

  if(!username) return setStatus("ç”¨æˆ·åä¸èƒ½ä¸ºç©º", true);
  if(!password) return setStatus("å¯†ç ä¸èƒ½ä¸ºç©º", true);

  if(!wsReady){
    setStatus("WebSocket æœªè¿æ¥ï¼Œæ­£åœ¨è¿æ¥â€¦");
    connectWS();
  }

  await startLogin(username, password);
});

/* =====================================================
   é€€å‡º
===================================================== */
$("btnLogout").addEventListener("click", ()=>{
  closeWS();
  wipeSensitiveMemory();
  pendingLogin = null;
  session.wsAuthed = false;
  session.lastLogin = null;

  backToLogin();
  setStatus("");
  toast("å·²é€€å‡º", "ok");

  connectWS();
});

/* =====================================================
   HTTP helper
===================================================== */
async function authedFetch(path, opt={}){
  const headers = opt.headers ? {...opt.headers} : {};
  if(session.httpToken){
    headers["Authorization"] = "Bearer " + session.httpToken;
  }
  return await fetch(HTTP_BASE + path, { ...opt, headers });
}

async function readJsonSafe(resp){
  try { return await resp.json(); } catch { return null; }
}

/* =====================================================
   Profileï¼šä¿å­˜æ˜µç§°
===================================================== */
$("btnSaveProfile").onclick = async ()=>{
  const name = ($("displayName").value || "").trim();
  $("profileHint").textContent = "";

  if(!session.httpToken){
    toast("æ²¡æœ‰ http_tokenï¼šåç«¯éœ€è¦åœ¨ login_result è¿”å› http_token", "err");
    $("profileHint").textContent = "ç¼ºå°‘ http_token";
    return;
  }

  try{
    const r = await authedFetch("/api/user/profile", {
      method: "PATCH",
      headers: { "Content-Type":"application/json" },
      body: JSON.stringify({ display_name: name })
    });

    const j = await readJsonSafe(r);

    if(!r.ok){
      toast("ä¿å­˜å¤±è´¥ï¼šHTTP " + r.status, "err");
      $("profileHint").textContent = "HTTP " + r.status;
      return;
    }
    if(!j || !j.success){
      toast("ä¿å­˜å¤±è´¥ï¼š" + ((j && j.error) ? j.error : "æœªçŸ¥é”™è¯¯"), "err");
      $("profileHint").textContent = (j && j.error) ? j.error : "æœªçŸ¥é”™è¯¯";
      return;
    }

    session.displayName = j.display_name ?? name;
    /* ===== æ–°å¢ï¼šç«‹åˆ»åŒæ­¥ UI ===== */
$("homeUser").textContent =
  "ç”¨æˆ·ï¼š" + (session.displayName || session.username);

$("displayName").value = session.displayName;
/* ============================ */

toast("æ˜µç§°å·²ä¿å­˜", "ok");
$("profileHint").textContent = "å·²ä¿å­˜";
    setTimeout(()=> $("profileHint").textContent="", 2000);

  }catch(e){
    console.error(e);
    toast("ä¿å­˜å¤±è´¥ï¼ˆç½‘ç»œ/å¼‚å¸¸ï¼‰", "err");
    $("profileHint").textContent = "å¼‚å¸¸";
  }
};

/* =====================================================
   å¤´åƒä¸Šä¼ 
===================================================== */
$("btnUploadAvatar").onclick = async ()=>{
  $("avatarHint").textContent = "";
  const f = $("avatarFile").files[0];
  if(!f) { toast("å…ˆé€‰ä¸ªå›¾ç‰‡", "warn"); return; }

  if(!session.httpToken){
    toast("æ²¡æœ‰ http_tokenï¼šå¤´åƒä¸Šä¼ éœ€è¦é‰´æƒ", "err");
    $("avatarHint").textContent = "ç¼ºå°‘ http_token";
    return;
  }

  try{
    const buf = await f.arrayBuffer();

    const r = await authedFetch("/api/avatar/upload", {
      method: "POST",
      headers: {
        "Content-Type": f.type || "application/octet-stream",
        "X-Filename": encodeURIComponent(f.name)
      },
      body: buf
    });

    if(!r.ok){
      toast("å¤´åƒä¸Šä¼ å¤±è´¥ï¼šHTTP " + r.status, "err");
      $("avatarHint").textContent = "HTTP " + r.status;
      return;
    }

    const j = await readJsonSafe(r);
    if(!j || !j.success){
      toast("å¤´åƒä¸Šä¼ å¤±è´¥ï¼š" + ((j && j.error) ? j.error : "æœªçŸ¥é”™è¯¯"), "err");
      $("avatarHint").textContent = (j && j.error) ? j.error : "æœªçŸ¥é”™è¯¯";
      return;
    }

    session.avatarUrl = j.avatar_url;
    $("avatarImg").src = HTTP_BASE + j.avatar_url + "?t=" + Date.now();
    toast("å¤´åƒå·²æ›´æ–°", "ok");
    $("avatarHint").textContent = "å·²æ›´æ–°";
    setTimeout(()=> $("avatarHint").textContent="", 2000);

  }catch(e){
    console.error(e);
    toast("å¤´åƒä¸Šä¼ å¤±è´¥ï¼ˆç½‘ç»œ/å¼‚å¸¸ï¼‰", "err");
    $("avatarHint").textContent = "å¼‚å¸¸";
  }
};

/* =====================================================
   æ”¹å¯†ç ï¼šç”Ÿæˆ newPasswordHash + newEncryptedPrivateKey
===================================================== */
document.getElementById("btnChangePassword").onclick = async ()=>{
  const oldPw = document.getElementById("oldPw").value;
  const newPw = document.getElementById("newPw").value;
  const newPw2 = document.getElementById("newPw2").value;

  if(!oldPw || !newPw || !newPw2)
    return toast("è¯·å¡«å†™å®Œæ•´", "warn");

  if(newPw !== newPw2)
    return toast("ä¸¤æ¬¡æ–°å¯†ç ä¸ä¸€è‡´", "warn");

  if(!isStrongPassword(newPw))
    return toast("æ–°å¯†ç å¼ºåº¦ä¸è¶³", "warn");

  if(!session.privateKeyPkcs8Bytes)
    return toast("æœ¬åœ°æ²¡æœ‰ç§é’¥ï¼Œæ— æ³•æ”¹å¯†ç ", "err");

  try{
    toast("è·å–å¯†ç å‚æ•°ä¸­â€¦", "warn");

    /* 1ï¸âƒ£ è·å– password hash å‚æ•° */
    const pwParams = await fetchPasswordParams();
    const oldSaltBytes = base64ToBytes(pwParams.salt);
    const oldIter = Number(pwParams.iterations);

    /* 2ï¸âƒ£ è®¡ç®— oldPasswordHash */
    const oldHashBytes =
      await derivePasswordHash(oldPw, oldSaltBytes, oldIter);

    const oldPasswordHash = {
      kdf: pwParams.kdf,
      iterations: oldIter,
      salt: pwParams.salt,
      hash: bufToBase64(oldHashBytes)
    };

    /* 3ï¸âƒ£ ç”Ÿæˆ newPasswordHash */
    const newSaltBytes = getRandomBytes(16);
    const newSaltB64 = bufToBase64(newSaltBytes);
    const newIter = 300000; // â† ä½ å¯ä»¥åœ¨è¿™é‡Œå‡çº§å®‰å…¨å¼ºåº¦

    const newHashBytes =
      await derivePasswordHash(newPw, newSaltBytes, newIter);

    const newPasswordHash = {
      kdf: "PBKDF2-HMAC-SHA256",
      iterations: newIter,
      salt: newSaltB64,
      hash: bufToBase64(newHashBytes)
    };

    /* 4ï¸âƒ£ ç”¨æ–°å¯†ç é‡æ–°åŠ å¯†ç§é’¥ */
    const keySalt = getRandomBytes(16);
    const iv = getRandomBytes(12);

    const aesKey = await deriveAesKey(
      newPw,
      keySalt,
      PBKDF2_ITER_KEY_DEFAULT,
      ["encrypt"]
    );

    const ct = await encryptPrivateKey(
      aesKey,
      iv,
      session.privateKeyPkcs8Bytes
    );

    const newEncryptedPrivateKey = {
      kdf: "PBKDF2-HMAC-SHA256",
      iterations: PBKDF2_ITER_KEY_DEFAULT,
      salt: bufToBase64(keySalt),
      cipher: "AES-256-GCM",
      iv: bufToBase64(iv),
      ciphertext: bufToBase64(ct)
    };

    /* 5ï¸âƒ£ æäº¤ç»™æœåŠ¡å™¨ */
    toast("æäº¤æ”¹å¯†ç è¯·æ±‚â€¦", "warn");

    const r = await fetch(HTTP_BASE + "/api/user/password", {
      method: "POST",
      headers: {
        "Authorization": "Bearer " + session.httpToken,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        oldPasswordHash,
        newPasswordHash,
        newEncryptedPrivateKey
      })
    });

    const j = await readJsonSafe(r);
    if(!r.ok) throw new Error("HTTP " + r.status);
    if(j && j.success === false)
      throw new Error(j?.error || "change password failed");

    toast("å¯†ç ä¿®æ”¹æˆåŠŸï¼ˆç§é’¥å·²é‡æ–°åŠ å¯†ï¼‰", "ok");

    document.getElementById("oldPw").value = "";
    document.getElementById("newPw").value = "";
    document.getElementById("newPw2").value = "";

  }catch(e){
    console.error(e);
    toast("æ”¹å¯†ç å¤±è´¥ï¼š" + e.message, "err");
  }
};


/* =====================================================
   æ³¨é”€è´¦å·
===================================================== */
$("btnDeleteAccount").onclick = async ()=>{
  $("delHint").textContent = "";

  if(!session.httpToken){
    toast("ç¼ºå°‘ http_tokenï¼šæ³¨é”€éœ€è¦é‰´æƒ", "err");
    $("delHint").textContent = "ç¼ºå°‘ http_token";
    return;
  }

  const pw = $("delPw").value;
  const confirm = ($("delConfirm").value || "").trim();

  if(!pw){
    toast("è¯·è¾“å…¥å¯†ç ç¡®è®¤", "warn");
    return;
  }
  if(confirm !== "DELETE"){
    toast("äºŒæ¬¡ç¡®è®¤éœ€è¦è¾“å…¥ DELETE", "warn");
    return;
  }

  try{
    toast("è·å–å¯†ç å‚æ•°ä¸­â€¦", "warn");
    $("delHint").textContent = "è·å–å‚æ•°â€¦";

    /* 1ï¸âƒ£ å®æ—¶è·å– password hash å‚æ•°ï¼ˆå…³é”®ä¿®æ­£ç‚¹ï¼‰ */
    const pwParams = await fetchPasswordParams();
    const iter = Number(pwParams.iterations);
    const saltBytes = base64ToBytes(pwParams.salt);

    /* 2ï¸âƒ£ è®¡ç®— passwordHash */
    const hashBytes = await derivePasswordHash(pw, saltBytes, iter);

    const passwordHash = {
      kdf: pwParams.kdf,
      iterations: iter,
      salt: pwParams.salt,
      hash: bufToBase64(hashBytes)
    };

    toast("æäº¤æ³¨é”€è¯·æ±‚â€¦", "warn");
    $("delHint").textContent = "æäº¤è¯·æ±‚â€¦";

    /* 3ï¸âƒ£ æäº¤æ³¨é”€è¯·æ±‚ */
    const r = await authedFetch("/api/user", {
      method: "DELETE",
      headers: { "Content-Type":"application/json" },
      body: JSON.stringify({ passwordHash })
    });

    const j = await readJsonSafe(r);

    if(!r.ok || !j || !j.success){
      throw new Error(j?.error || "delete account failed");
    }

    toast("è´¦å·å·²æ³¨é”€ï¼ˆæœ¬åœ°å°†é€€å‡ºï¼‰", "ok");

    /* 4ï¸âƒ£ æœ¬åœ°æ¸…ç† + å›ç™»å½•é¡µ */
    closeWS();
    wipeSensitiveMemory();
    pendingLogin = null;

    $("delPw").value = "";
    $("delConfirm").value = "";
    $("panelDelete").open = false;

    backToLogin();
    setStatus("");

    connectWS();

  }catch(e){
    console.error(e);
    toast("æ³¨é”€å¤±è´¥ï¼š" + e.message, "err");
    $("delHint").textContent = "å¤±è´¥";
  }
};
const drawer = document.getElementById("settingsDrawer");

$("btnSettings").onclick = ()=>{
  drawer.classList.remove("hidden");
};

$("btnCloseSettings").onclick = ()=>{
  drawer.classList.add("hidden");
};

drawer.querySelector(".settings-mask").onclick = ()=>{
  drawer.classList.add("hidden");
};
async function loadFriends(){
  console.log("[friends] loadFriends start", { hasToken: !!session.httpToken });
  const r = await authedFetch("/api/friends");
  console.log("[friends] response", r.status);
  const j = await readJsonSafe(r);
  console.log("[friends] body", j);

  if(!r.ok || !j.success){
    toast("å¥½å‹åˆ—è¡¨åŠ è½½å¤±è´¥", "err");
    return;
  }

  friends = j.friends || [];
  friendRequests = j.requests || [];

  // pre-derive session keys for friends with public_key.spki
  for (const f of friends) {
    if (!f.public_key || !f.public_key.spki) continue;
    if (sessionKeys.has(f.username)) continue;
    try {
      const key = await deriveSessionKey(f.public_key.spki);
      sessionKeys.set(f.username, key);
    } catch (e) {
      // ignore key derivation errors; user can retry later
    }
  }

  renderFriendList();
  renderRequestList();
}


function renderFriendList(){
  const box = document.getElementById("friendList");
  box.innerHTML = "";

  for(const f of friends){
    const div = document.createElement("div");
    div.className = "im-item";

    const avatar = HTTP_BASE + (f.avatar_url || "/resources/avatars/default.png");

    div.innerHTML = `
      <div class="row" style="gap:10px;">
        <img src="${avatar}" style="width:36px;height:36px;border-radius:50%">
        <div style="flex:1">${escapeHtml(f.display_name || f.username)}</div>
        <button class="btn ghost btn-sm">â‹®</button>
      </div>
    `;

    div.onclick = (e)=>{
      if(e.target.tagName === "BUTTON") return;
      selectFriend(f, e);
    };

    // åˆ é™¤å¥½å‹
    div.querySelector("button").onclick = ()=>{
      deleteFriend(f.username);
    };

    box.appendChild(div);
  }
}

async function deleteFriend(username){
  if(!confirm("ç¡®å®šåˆ é™¤å¥½å‹ï¼Ÿ")) return;

  const r = await authedFetch("/api/friends", {
    method: "DELETE",
    headers: { "Content-Type":"application/json" },
    body: JSON.stringify({ username })
  });

  const j = await readJsonSafe(r);

  if(!r.ok || !j.success){
    toast(j?.error || "åˆ é™¤å¤±è´¥", "err");
    return;
  }

  sessionKeys.delete(username);

  toast("å¥½å‹å·²åˆ é™¤", "ok");
  loadFriends();

  clearChatSelection();
}



function selectFriend(f,e){
 currentChat=f;

 document.querySelectorAll(".im-item").forEach(x=>x.classList.remove("active"));
 e.currentTarget.classList.add("active");

 chatMessages.innerHTML="";
 if(chatMessages) chatMessages.classList.remove("hidden");
 if(chatPlaceholder) chatPlaceholder.classList.add("hidden");
 if(chatInputArea) chatInputArea.classList.remove("hidden");
 if(chatTitle) chatTitle.textContent = f.display_name || f.username;
 if(chatSub) chatSub.textContent = "ä¸ " + (f.username || "") + " çš„å¯¹è¯";
 if(btnCloseChat) btnCloseChat.classList.remove("hidden");
 loadHistory(f.username);
 setMobilePane("chat");
}

function clearChatSelection(){
  currentChat = null;
  document.querySelectorAll(".im-item").forEach(x=>x.classList.remove("active"));
  if(chatMessages){
    chatMessages.innerHTML = "";
    chatMessages.classList.add("hidden");
  }
  if(chatPlaceholder) chatPlaceholder.classList.remove("hidden");
  if(chatInputArea) chatInputArea.classList.add("hidden");
  if(chatTitle) chatTitle.textContent = "æœªé€‰æ‹©èŠå¤©";
  if(chatSub) chatSub.textContent = "è¯·é€‰æ‹©ä¸€ä¸ªå¥½å‹å¼€å§‹èŠå¤©";
  if(btnCloseChat) btnCloseChat.classList.add("hidden");

  setMobilePane("list");
}

document.getElementById("btnAddFriend").onclick = async ()=>{
  const name = prompt("è¾“å…¥å¯¹æ–¹ç”¨æˆ·å");
  if(!name) return;

  let r;
  try{
    r = await authedFetch("/api/friends/request", {
      method: "POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify({ username: name })
    });
  }catch(e){
    toast("network_error", "err");
    return;
  }

  if(!r.ok){
    toast("http_error", "err");
    return;
  }

  const data = await r.json();

  if(data.success){
    if(data.status === "accepted"){
    // å¯¹æ–¹ä¹‹å‰å·²ç»è¯·æ±‚è¿‡ â†’ ç›´æ¥æˆä¸ºå¥½å‹

      const key = await deriveSessionKey(data.public_key.spki);
      sessionKeys.set(name, key);

      toast("å·²è‡ªåŠ¨äº’åŠ ä¸ºå¥½å‹", "ok");
      loadFriends();
      return;
    }
    else if(data.status === "pending"){
      toast("å·²å‘é€å¥½å‹è¯·æ±‚", "ok");
      return;
    }
    toast(data.status || "ok", "ok");
  }else{
    toast(data.error || "unknown_error", "err");
  }
};


function renderRequestList(){
  const box = document.getElementById("requestList");
  box.innerHTML = "";

  for(const r of friendRequests){
    const div = document.createElement("div");
    div.className = "im-item";

    const avatar = HTTP_BASE + (r.avatar_url || "/resources/avatars/default.png");

    div.innerHTML = `
      <div class="row" style="gap:10px;">
        <img src="${avatar}" style="width:32px;height:32px;border-radius:50%">
        <div>${escapeHtml(r.display_name || r.username)}</div>
      </div>

      <div class="row" style="margin-top:6px;">
        <button class="btn primary btn-sm">åŒæ„</button>
        <button class="btn danger btn-sm">æ‹’ç»</button>
      </div>
    `;

    div.querySelector(".btn.primary").onclick =
      ()=>acceptFriend(r.username);

    div.querySelector(".btn.danger").onclick =
      ()=>rejectFriend(r.username);

    box.appendChild(div);
  }
}

async function deriveSessionKey(peerSpkiB64){
  const peerKey = await crypto.subtle.importKey(
    "spki",
    base64ToBytes(peerSpkiB64),
    { name:"ECDH", namedCurve:"P-256" },
    false,
    []
  );

  return await crypto.subtle.deriveKey(
    { name:"ECDH", public: peerKey },
    session.privateKeyCryptoKey,
    { name:"AES-GCM", length:256 },
    false,
    ["encrypt","decrypt"]
  );
}
async function acceptFriend(username){
  const r = await authedFetch("/api/friends/accept", {
    method: "POST",
    headers: {"Content-Type":"application/json"},
    body: JSON.stringify({ username })
  });

  const j = await readJsonSafe(r);
  if(!r.ok || !j.success){
    toast("åŒæ„å¤±è´¥", "err");
    return;
  }

  const key = await deriveSessionKey(j.public_key.spki);
  sessionKeys.set(username, key);

  toast("å¥½å‹å·²æ·»åŠ ", "ok");
  // optimistic UI update to avoid needing a manual refresh
  friendRequests = friendRequests.filter(r => r.username !== username);
  if(!friends.find(f => f.username === username)){
    const req = friendRequests.find(r => r.username === username);
    friends.unshift({
      username,
      display_name: req ? req.display_name : "",
      avatar_url: req ? req.avatar_url : "/resources/avatars/default.png",
      public_key: j.public_key
    });
  }
  renderFriendList();
  renderRequestList();
  await loadFriends();
}

async function rejectFriend(username){
  const r = await authedFetch("/api/friends/reject", {
    method: "POST",
    headers: {"Content-Type":"application/json"},
    body: JSON.stringify({ username })
  });
  const j = await readJsonSafe(r);
  if(!r.ok || !j.success){
    toast("æ‹’ç»å¤±è´¥", "err");
    return;
  }
  toast("å·²æ‹’ç»", "ok");
  loadFriends();
}

async function handleFriendAccepted(msg){
  const username = msg.username;
  if(!username) return;
  if(!friends.find(f => f.username === username)){
    friends.unshift({
      username,
      display_name: msg.display_name || "",
      avatar_url: msg.avatar_url || "/resources/avatars/default.png",
      public_key: msg.public_key
    });
  }
  if(msg.public_key && msg.public_key.spki){
    try{
      const key = await deriveSessionKey(msg.public_key.spki);
      sessionKeys.set(username, key);
    }catch{}
  }
  renderFriendList();
  renderRequestList();
  if(typeof toast === "function") toast("å·²æˆä¸ºå¥½å‹", "ok");
}

function handleFriendRemoved(msg){
  const username = msg.username;
  if(!username) return;
  const uname = String(username).toLowerCase();
  friends = friends.filter(f => String(f.username || "").toLowerCase() !== uname);
  friendRequests = friendRequests.filter(r => String(r.username || "").toLowerCase() !== uname);
  sessionKeys.delete(username);
  if(currentChat && String(currentChat.username || "").toLowerCase() === uname){
    clearChatSelection();
  }
  renderFriendList();
  renderRequestList();
  if(typeof toast === "function") toast("å¯¹æ–¹å·²åˆ é™¤å¥½å‹", "warn");
}


/* =====================================================
   é¡µé¢åŠ è½½ï¼šè‡ªåŠ¨è¿æ¥ WS
===================================================== */
connectWS();

document.addEventListener("visibilitychange", ()=>{
  if(document.visibilityState === "visible"){
    if(!ws || ws.readyState !== WebSocket.OPEN){
      connectWS();
    }
  }
});

window.addEventListener("resize", ()=>{
  setMobilePane(currentChat ? "chat" : "list");
});
</script>

</body>
</html>
