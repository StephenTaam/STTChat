<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>STTChat</title>
<link rel="icon" type="image/png" href="imags/favicon.png">

<style>
  :root{
    --bg: #0b1020;
    --card: rgba(255,255,255,0.06);
    --card2: rgba(255,255,255,0.08);
    --border: rgba(255,255,255,0.10);
    --text: rgba(255,255,255,0.92);
    --muted: rgba(255,255,255,0.65);
    --muted2: rgba(255,255,255,0.55);
    --primary: #3b82f6;
    --primary2:#2563eb;
    --danger:#ef4444;
    --danger2:#dc2626;
    --ok:#22c55e;
    --shadow: 0 18px 60px rgba(0,0,0,.45);
    --radius: 16px;
  }

  *{ box-sizing: border-box; }
  html,body{ height:100%; }
  body{
    margin:0;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "PingFang SC", "Hiragino Sans GB", "Microsoft Yahei", Arial, sans-serif;
    color: var(--text);
    background:
      radial-gradient(1200px 600px at 10% 10%, rgba(59,130,246,.28), transparent 55%),
      radial-gradient(900px 500px at 90% 20%, rgba(34,197,94,.20), transparent 60%),
      radial-gradient(900px 500px at 70% 90%, rgba(239,68,68,.18), transparent 55%),
      linear-gradient(180deg, #070a14, #050714);
  }

  .container{
    max-width: 980px;
    margin: 22px auto;
    padding: 0 14px 50px;
  }

  .brandbar{
    display:flex;
    align-items:center;
    justify-content: space-between;
    gap: 12px;
    margin-bottom: 14px;
  }
  .brand{
    display:flex;
    align-items:center;
    gap: 10px;
  }
  .logo{
    width: 38px;
    height: 38px;
    border-radius: 12px;
    background: linear-gradient(135deg, rgba(59,130,246,.9), rgba(34,197,94,.75));
    box-shadow: 0 12px 28px rgba(59,130,246,.25);
  }
  .brand h1{
    margin:0;
    font-size: 18px;
    letter-spacing: .2px;
  }
  .brand .sub{
    font-size: 12px;
    color: var(--muted);
    margin-top: 1px;
  }

  .grid{
    display:grid;
    grid-template-columns: 1.2fr .8fr;
    gap: 14px;
  }
  @media (max-width: 860px){
    .grid{ grid-template-columns: 1fr; }
  }

  .card{
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    box-shadow: var(--shadow);
    padding: 14px;
  }
  .card.soft{
    background: rgba(255,255,255,0.04);
    box-shadow: none;
  }

  .title{
    display:flex;
    align-items:center;
    justify-content: space-between;
    gap: 10px;
    margin-bottom: 10px;
  }
  .title h2{
    margin:0;
    font-size: 15px;
    color: rgba(255,255,255,.92);
  }
  .hint{
    font-size: 12px;
    color: var(--muted);
  }

  label{
    display:block;
    margin-top: 10px;
    font-size: 12px;
    color: var(--muted);
  }
  input{
    width:100%;
    margin-top:6px;
    padding: 10px 12px;
    border-radius: 12px;
    border: 1px solid rgba(255,255,255,0.10);
    background: rgba(255,255,255,0.06);
    color: var(--text);
    outline:none;
    transition: .15s ease;
  }
  input::placeholder{ color: rgba(255,255,255,.35); }
  input:focus{
    border-color: rgba(59,130,246,.65);
    box-shadow: 0 0 0 4px rgba(59,130,246,.15);
    background: rgba(255,255,255,0.075);
  }

  .row{
    display:flex;
    gap: 10px;
    align-items:center;
    flex-wrap: wrap;
  }

  .btn{
    appearance:none;
    border:none;
    border-radius: 12px;
    padding: 10px 12px;
    cursor:pointer;
    font-weight: 600;
    color: rgba(255,255,255,.92);
    background: rgba(255,255,255,0.08);
    border: 1px solid rgba(255,255,255,0.10);
    transition: .15s ease;
    user-select:none;
  }
  .btn:hover{ transform: translateY(-1px); background: rgba(255,255,255,0.11); }
  .btn:active{ transform: translateY(0px); }
  .btn.primary{
    background: linear-gradient(135deg, var(--primary), var(--primary2));
    border-color: rgba(255,255,255,0.10);
  }
  .btn.primary:hover{ filter: brightness(1.05); }
  .btn.danger{
    background: linear-gradient(135deg, var(--danger), var(--danger2));
    border-color: rgba(255,255,255,0.10);
  }
  .btn.ghost{
    background: transparent;
  }
  .btn.full{ width:100%; }

  .pill{
    display:inline-flex;
    align-items:center;
    gap: 8px;
    padding: 6px 10px;
    border-radius: 999px;
    border: 1px solid rgba(255,255,255,0.12);
    background: rgba(255,255,255,0.05);
    font-size: 12px;
    color: rgba(255,255,255,0.78);
  }
  .dot{
    width:8px;height:8px;border-radius:999px;
    background: rgba(255,255,255,0.40);
  }
  .dot.ok{ background: rgba(34,197,94,.95); }
  .dot.bad{ background: rgba(239,68,68,.95); }
  .dot.warn{ background: rgba(245,158,11,.95); }

  .muted{ color: var(--muted); font-size: 12px; line-height: 1.45; }
  .muted a{ color: rgba(147,197,253,.95); text-decoration:none; }
  .muted a:hover{ text-decoration: underline; }

  .sep{ height:1px; background: rgba(255,255,255,0.10); margin: 12px 0; }

  /* Login password eye */
  .pw-wrapper{ position: relative; }
  .toggle-eye{
    position:absolute;
    right: 10px;
    top: 36px;
    cursor:pointer;
    user-select:none;
    font-size: 16px;
    opacity:.85;
  }

  /* Avatar */
  .avatar{
    width: 72px;
    height: 72px;
    border-radius: 999px;
    border: 1px solid rgba(255,255,255,0.18);
    background: rgba(255,255,255,0.06);
    object-fit: cover;
  }

  /* Toast */
  .toast-wrap{
    position: fixed;
    right: 16px;
    top: 16px;
    display:flex;
    flex-direction: column;
    gap: 10px;
    z-index: 999;
    pointer-events: none;
  }
  .toast{
    pointer-events: auto;
    min-width: 260px;
    max-width: 420px;
    padding: 10px 12px;
    border-radius: 14px;
    border: 1px solid rgba(255,255,255,0.14);
    background: rgba(14,18,35,0.90);
    box-shadow: 0 18px 60px rgba(0,0,0,.55);
    backdrop-filter: blur(10px);
    display:flex;
    gap: 10px;
    align-items:flex-start;
  }
  .toast .badge{
    width: 10px;
    height: 10px;
    border-radius: 999px;
    margin-top: 4px;
    background: rgba(255,255,255,.45);
  }
  .toast.ok .badge{ background: rgba(34,197,94,.95); }
  .toast.err .badge{ background: rgba(239,68,68,.95); }
  .toast.warn .badge{ background: rgba(245,158,11,.95); }
  .toast .msg{
    font-size: 12px;
    color: rgba(255,255,255,.86);
    line-height: 1.45;
  }
  .toast .x{
    margin-left:auto;
    cursor:pointer;
    opacity:.7;
    user-select:none;
  }
  .toast .x:hover{ opacity:1; }

  /* Collapsible */
  details{
    border: 1px solid rgba(255,255,255,0.10);
    border-radius: 14px;
    padding: 10px 12px;
    background: rgba(255,255,255,0.04);
  }
  details summary{
    cursor:pointer;
    list-style:none;
    display:flex;
    align-items:center;
    justify-content: space-between;
    gap: 10px;
    font-weight: 700;
    font-size: 13px;
    color: rgba(255,255,255,.9);
  }
  details summary::-webkit-details-marker{ display:none; }
  details[open]{ background: rgba(255,255,255,0.05); }
  .caret{ opacity:.7; }

  /* hidden */
  .hidden{ display:none; }

  /* ===== Settings Drawer ===== */
.settings{
  position: fixed;
  inset: 0;
  z-index: 1000;
}

.settings-mask{
  position:absolute;
  inset:0;
  background: rgba(0,0,0,.45);
  backdrop-filter: blur(4px);
}

.settings-panel{
  position:absolute;
  right:0;
  top:0;
  width: 420px;
  max-width: 92%;
  height:100%;
  background: rgba(10,14,28,.98);
  border-left: 1px solid rgba(255,255,255,.12);
  box-shadow: -20px 0 60px rgba(0,0,0,.55);
  padding: 16px;
  overflow-y: auto;
}

.settings-header{
  display:flex;
  justify-content: space-between;
  align-items:center;
  margin-bottom: 12px;
}
/* ===== IM Layout ===== */
.im-layout{
  display:flex;
  height: 460px;
}

.im-sidebar{
  width: 260px;
  border-right: 1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.03);
  display:flex;
  flex-direction: column;
}

.im-sidebar-header{
  padding: 10px;
  display:flex;
  justify-content: space-between;
  align-items:center;
  font-weight:700;
}

.im-list{
  flex:1;
  overflow-y:auto;
}

.im-item{
  padding: 10px;
  cursor:pointer;
  border-bottom: 1px solid rgba(255,255,255,.06);
}
.im-item:hover{
  background: rgba(255,255,255,.06);
}
.im-item.active{
  background: rgba(59,130,246,.18);
}

.im-main{
  flex:1;
  display:flex;
  align-items:center;
  justify-content:center;
}

.im-placeholder{
  color: var(--muted);
}
.msg{max-width:70%;padding:8px;border-radius:12px;margin:6px}
.msg.me{margin-left:auto;background:#3b82f6}
.msg.peer{background:rgba(255,255,255,.12)}
.msg img{max-width:100%;border-radius:8px}

</style>
</head>

<body>
<div class="toast-wrap" id="toastWrap"></div>

<div class="container">

  <!-- ========== ç™»å½•è§†å›¾ ========== -->
  <div id="viewLogin">
    <div class="brandbar">
      <div class="brand">
        <div class="logo"></div>
        <div>
          <h1>STTChat</h1>
          <div class="sub">ç«¯åˆ°ç«¯åŠ å¯† Â· ç§é’¥ä»…ä¿å­˜åœ¨å†…å­˜</div>
        </div>
      </div>
      <div class="row">
        <span class="pill" title="WebSocket çŠ¶æ€">
          <span id="wsDot" class="dot bad"></span>
          <span id="wsState">æœªè¿æ¥</span>
        </span>
      </div>
    </div>

    <div class="grid">
      <div class="card">
        <div class="title">
          <h2>ç™»å½•</h2>
          <span class="hint">WS challenge â†’ è®¡ç®— hash â†’ ç™»å½• â†’ è§£å¯†ç§é’¥</span>
        </div>

        <form id="loginForm">
          <label>
            ç”¨æˆ·å
            <input id="username" type="text" required autocomplete="username" placeholder="è¾“å…¥ç”¨æˆ·å" />
          </label>

          <label>
            å¯†ç 
            <div class="pw-wrapper">
              <input id="password" type="password" required autocomplete="current-password" placeholder="è¾“å…¥å¯†ç " />
              <span id="togglePw" class="toggle-eye">ğŸ‘</span>
            </div>
            <div class="muted" style="margin-top:6px;">æç¤ºï¼šç™»å½•æ—¶å¿…é¡»ä½¿ç”¨æœåŠ¡å™¨è¿”å›çš„ salt æ‰èƒ½ç®—å‡ºä¸€è‡´çš„ passwordHashã€‚</div>
          </label>

          <button class="btn primary full" type="submit" style="margin-top:12px;">ç™»å½•</button>

          <div id="status" class="muted" style="margin-top:10px;"></div>
        </form>
      </div>

      <div class="card soft">
        <div class="title">
          <h2>å¼€å§‹ä½¿ç”¨</h2>
          <span class="hint">è½»é‡è®¾ç½®</span>
        </div>

        <div class="muted">
          <div style="margin-bottom:10px;">
            <div class="row" style="gap:8px;">
              <span class="pill"><span class="dot warn"></span>æ‰“å¼€é¡µé¢ä¼šè‡ªåŠ¨å»ºç«‹ wss è¿æ¥</span>
              <span class="pill"><span class="dot warn"></span>é€€å‡ºä¼šæ–­å¼€å¹¶é‡å»ºæ–°è¿æ¥</span>
            </div>
          </div>

          <div class="sep"></div>

          <div class="row" style="justify-content: space-between;">
            <div>
              æ²¡æœ‰è´¦å·ï¼Ÿ
              <a id="linkRegister" href="#">å»æ³¨å†Œ</a>
            </div>
            <button class="btn ghost" id="btnReconnect" type="button">æ‰‹åŠ¨é‡è¿ WS</button>
          </div>

          <div class="sep"></div>

          <div class="muted">
            å®‰å…¨æ¨¡å‹ï¼š
            <ul style="margin:8px 0 0 18px; padding:0;">
              <li>å¯†ç ï¼šPBKDF2-HMAC-SHA256 æ´¾ç”Ÿ passwordHash</li>
              <li>ç§é’¥ï¼šAES-256-GCM åŠ å¯†å­˜æœåŠ¡å™¨ï¼Œå®¢æˆ·ç«¯è§£å¯†åä»…å­˜åœ¨å†…å­˜</li>
              <li>HTTP tokenï¼šä»…ç”¨äºèµ„æ–™/å¤´åƒç­‰â€œè´¦æˆ·ç®¡ç†â€æ¥å£</li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- ========== ä¸»é¡µè§†å›¾ ========== -->
  <!-- ========== ä¸»é¡µè§†å›¾ï¼ˆIM ä¸»ç•Œé¢ï¼‰ ========== -->
<div id="viewHome" class="hidden">

  <!-- é¡¶æ  -->
  <div class="brandbar">
    <div class="brand">
      <div class="logo"></div>
      <div>
        <h1>STTChat</h1>
        <div class="sub">Secure IM Â· End-to-End Encrypted</div>
      </div>
    </div>

    <div class="row">
      <span class="pill" title="WebSocket çŠ¶æ€">
        <span id="wsDotHome" class="dot bad"></span>
        <span id="homeWs">WSï¼š-</span>
      </span>

      <!-- â­ æ–°å¢ï¼šè®¾ç½®æŒ‰é’® -->
      <button class="btn ghost" id="btnSettings">âš™ è®¾ç½®</button>

      <button class="btn" id="btnLogout" type="button">é€€å‡º</button>
    </div>
  </div>

  <!-- IM ä¸»åŒºåŸŸ -->
  <div class="card" style="padding:0; overflow:hidden;">
    <div class="im-layout">
  
      <!-- å·¦ä¾§ï¼šå¥½å‹ / ä¼šè¯åˆ—è¡¨ -->
      <div class="im-sidebar">
        <div class="im-sidebar-header">
          <span>å¥½å‹</span>
          <button class="btn ghost" id="btnAddFriend">ï¼‹</button>
        </div>
      
        <div id="friendList" class="im-list"></div>
      
        <div class="sep"></div>
        <div class="muted" style="padding:8px;">å¥½å‹è¯·æ±‚</div>
        <div id="requestList" class="im-list"></div>
      </div>
      
  
      <!-- å³ä¾§ï¼šèŠå¤©åŒº -->
      <div class="im-main" id="chatMain">
        <div id="chatMessages" style="flex:1;overflow-y:auto;padding:10px"></div>
      
        <div style="border-top:1px solid rgba(255,255,255,.1);padding:8px">
          <div class="row">
            <input id="chatInput" placeholder="è¾“å…¥æ¶ˆæ¯â€¦" style="flex:1">
            <button class="btn ghost" id="btnEmoji">ğŸ˜€</button>
            <input type="file" id="fileInput" hidden>
            <button class="btn ghost" id="btnFile">ğŸ“</button>
            <button class="btn primary" id="btnSend">å‘é€</button>
          </div>
        </div>
      </div>
      
  
    </div>
  </div>
  

</div>


</div>
<!-- ========== è®¾ç½®æŠ½å±‰ ========== -->
<div id="settingsDrawer" class="settings hidden">
  <div class="settings-mask"></div>

  <div class="settings-panel">

    <div class="settings-header">
      <h2>è®¾ç½®</h2>
      <button class="btn ghost" id="btnCloseSettings">âœ•</button>
    </div>

    <!-- ===== Profile ===== -->
    <div class="card">
      <div class="title">
        <h2>ä¸ªäººèµ„æ–™</h2>
        <span class="hint">å¤´åƒ / æ˜µç§°</span>
      </div>

      <div class="row" style="align-items: center; gap: 14px;">
        <img id="avatarImg" class="avatar" alt="avatar">
        <div style="flex:1; min-width: 220px;">
          <div class="row" style="justify-content: space-between;">
            <span class="pill" id="homeUser">ç”¨æˆ·ï¼š-</span>
            <span class="pill" id="homeKey">ç§é’¥ï¼š-</span>
          </div>
          <div class="muted" style="margin-top:8px;">
            ç§é’¥åªåœ¨å†…å­˜ä¸­ï¼›é€€å‡ºä¼šæ¸…ç©ºå¹¶æ–­å¼€ WSã€‚
          </div>
        </div>
      </div>

      <div class="sep"></div>

      <label>
        æ˜µç§°ï¼ˆdisplay_nameï¼‰
        <input id="displayName" type="text"
               placeholder="æ¯”å¦‚ï¼šStephenTaam" maxlength="32">
      </label>
      <div class="row" style="margin-top:10px;">
        <button class="btn primary" id="btnSaveProfile" type="button">
          ä¿å­˜æ˜µç§°
        </button>
        <span class="muted" id="profileHint"></span>
      </div>

      <div class="sep"></div>

      <label>
        ä¿®æ”¹å¤´åƒ
        <input type="file" id="avatarFile" accept="image/*">
      </label>
      <div class="row" style="margin-top:10px;">
        <button class="btn" id="btnUploadAvatar" type="button">
          ä¸Šä¼ å¤´åƒ
        </button>
        <span class="muted" id="avatarHint"></span>
      </div>
    </div>

    <!-- Right: Security + Danger -->
    <div class="card soft">
      <div class="title">
        <h2>å®‰å…¨</h2>
        <span class="hint">æ”¹å¯†ç ä¼šé‡æ–°åŠ å¯†ç§é’¥</span>
      </div>

      <details id="panelPassword">
        <summary>
          æ”¹å¯†ç 
          <span class="caret">â–¾</span>
        </summary>

        <div class="muted" style="margin-top:10px;">
          æ”¹å¯†ç éœ€è¦ï¼š
          <ul style="margin:6px 0 0 18px; padding:0;">
            <li>ç”¨æ—§å¯†ç æ ¡éªŒ oldPasswordHash</li>
            <li>ç”¨æ–°å¯†ç ç”Ÿæˆ newPasswordHash</li>
            <li>ç”¨æ–°å¯†ç æ´¾ç”Ÿ AES key é‡æ–°åŠ å¯†ç§é’¥å¹¶æäº¤</li>
          </ul>
        </div>

        <label>
          æ—§å¯†ç 
          <input id="oldPw" type="password" autocomplete="current-password" placeholder="è¾“å…¥æ—§å¯†ç ">
        </label>
        <label>
          æ–°å¯†ç 
          <input id="newPw" type="password" autocomplete="new-password" placeholder="è¾“å…¥æ–°å¯†ç ï¼ˆå»ºè®® 10+ ä½ï¼‰">
        </label>
        <label>
          ç¡®è®¤æ–°å¯†ç 
          <input id="newPw2" type="password" autocomplete="new-password" placeholder="å†æ¬¡è¾“å…¥æ–°å¯†ç ">
        </label>

        <div class="row" style="margin-top:10px;">
          <button class="btn primary" id="btnChangePassword" type="button">æäº¤æ”¹å¯†ç </button>
          <span class="muted" id="pwHint"></span>
        </div>
      </details>

      <div class="sep"></div>

      <div class="title">
        <h2 style="color: rgba(255,255,255,.9);">Danger Zone</h2>
        <span class="hint" style="color: rgba(255,255,255,.55);">ä¸å¯æ¢å¤</span>
      </div>

      <details id="panelDelete">
        <summary>
          æ³¨é”€è´¦å·ï¼ˆæ°¸ä¹…åˆ é™¤ï¼‰
          <span class="caret">â–¾</span>
        </summary>

        <div class="muted" style="margin-top:10px;">
          è¿™æ˜¯å±é™©æ“ä½œï¼šä¼šåˆ é™¤ä½ çš„è´¦å·æ•°æ®ã€‚å»ºè®®ä½ è¦æ±‚ç”¨æˆ·è¾“å…¥å¯†ç å†æ¬¡ç¡®è®¤ã€‚
        </div>

        <label>
          è¾“å…¥å¯†ç ç¡®è®¤
          <input id="delPw" type="password" autocomplete="current-password" placeholder="è¾“å…¥å½“å‰å¯†ç ">
        </label>

        <label>
          äºŒæ¬¡ç¡®è®¤ï¼ˆè¾“å…¥ DELETEï¼‰
          <input id="delConfirm" type="text" placeholder="DELETE">
        </label>

        <div class="row" style="margin-top:10px;">
          <button class="btn danger" id="btnDeleteAccount" type="button">æˆ‘ç¡®è®¤æ³¨é”€è´¦å·</button>
          <span class="muted" id="delHint"></span>
        </div>
      </details>

      <div class="sep"></div>
      <div class="muted">
        è¿æ¥ä¿¡æ¯ï¼š
        <div class="row" style="margin-top:8px; gap:8px;">
          <span class="pill" id="pillHttp">HTTPï¼š-</span>
          <span class="pill" id="pillWs">WSï¼š-</span>
        </div>
      </div>
    </div>

  </div>
</div>


<script>
/* =====================================================
   é…ç½®ï¼šä½ éœ€è¦æ”¹è¿™é‡Œ
===================================================== */
const HTTP_BASE = "https://42.51.13.120:8080"; // â† ä½ çš„ HTTP æœåŠ¡ IP + ç«¯å£
const WS_URL = "wss://42.51.13.120:5050";     // â† ä½ çš„ wss åœ°å€
const REGISTER_URL = "resources/signup.html";  // â† ä½ çš„æ³¨å†Œé¡µ
/* =====================================================
   å¯†ç å­¦å‚æ•°
===================================================== */
const PBKDF2_ITER_PWHASH = 200000;     // ç™»å½• passwordHash é»˜è®¤ iterations
const PBKDF2_ITER_KEY_DEFAULT = 200000; // è‹¥æœåŠ¡å™¨æ²¡è¿”å› iterationsï¼Œå°±ç”¨è¿™ä¸ª
const textEncoder = new TextEncoder();

/* =====================================================
   Toast
===================================================== */
function toast(msg, type="ok", ms=3200){
  const wrap = document.getElementById("toastWrap");
  const el = document.createElement("div");
  el.className = "toast " + (type === "err" ? "err" : (type === "warn" ? "warn" : "ok"));
  el.innerHTML = `
    <div class="badge"></div>
    <div class="msg">${escapeHtml(msg)}</div>
    <div class="x">âœ•</div>
  `;
  wrap.appendChild(el);
  const rm = ()=>{ try{ el.remove(); }catch{} };
  el.querySelector(".x").onclick = rm;
  setTimeout(rm, ms);
}
function escapeHtml(s){
  return String(s).replace(/[&<>"']/g, (c)=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[c]));
}

/* =====================================================
   å…¨å±€çŠ¶æ€ï¼ˆåªæ”¾å†…å­˜ï¼‰
===================================================== */
let friendRequests = []; // [{username, display_name}]
const sessionKeys = new Map(); // peer -> CryptoKey
const pendingSendByTs = new Map(); // client ts -> pending meta

let friends = []; // [{username, display_name, avatar_url}]
let currentChat = null;

let reconnectTimer = null;
let reconnectDelay = 3000;
let ws = null;
let wsReady = false;

let session = {
  username: null,
  displayName: null,
  avatarUrl : null,
  httpToken : null,

  // ç™»å½• challenge çš„ password hash å‚æ•°ï¼ˆåç»­æ”¹å¯†ç /æ³¨é”€ç”¨ï¼‰
  pwSaltB64: null,
  pwIterations: null,

  // è§£å¯†å‡ºçš„ç§é’¥ï¼ˆåªåœ¨å†…å­˜ï¼‰
  privateKeyPkcs8Bytes: null,  // Uint8Array
  privateKeyCryptoKey: null,   // CryptoKeyï¼ˆå¯é€‰ï¼‰
  publicKeySpkiBytes: null,    // Uint8Arrayï¼ˆå¯é€‰ï¼‰
  publicKeyCryptoKey: null
};

/* =====================================================
   å°å·¥å…·
===================================================== */
const chatInput = document.getElementById("chatInput");
const btnSend = document.getElementById("btnSend");
const btnEmoji = document.getElementById("btnEmoji");
const btnFile = document.getElementById("btnFile");
const fileInput = document.getElementById("fileInput");
const chatMessages = document.getElementById("chatMessages");

async function sendEncrypted(kind,data,meta={}){
 if(!currentChat || !currentChat.username) throw new Error("no current chat");
 if(!ws || ws.readyState !== WebSocket.OPEN) throw new Error("ws not connected");

 let key=sessionKeys.get(currentChat.username);
 if(key && typeof key.then === "function"){
  key = await key;
  sessionKeys.set(currentChat.username, key);
 }
 if(!key) throw new Error("missing session key");
 if(typeof CryptoKey !== "undefined" && !(key instanceof CryptoKey)){
  throw new Error("invalid session key");
 }
 const iv=getRandomBytes(12);

 const ct=await crypto.subtle.encrypt({name:"AES-GCM",iv},key,data);
 const clientTs = Date.now();
 pendingSendByTs.set(String(clientTs), {
  to: currentChat.username,
  kind
 });

 ws.send(JSON.stringify({
  type:"chat_send",
  to:currentChat.username,
  ts: clientTs,
  payload:{
   kind,
   ...meta,
   iv:bufToBase64(iv),
   ciphertext:bufToBase64(ct)
  }
 }));

 // local echo so sender sees the message even if server does not echo back
 try{
  renderMessage(session.username, kind, data, meta, clientTs);
 }catch{}
}


btnSend.onclick=async()=>{
 try{
  await sendEncrypted("text",strToUint8(chatInput.value),{
   mime:"text/plain",
   size:chatInput.value.length
  });
  chatInput.value="";
 }catch(err){
  toast("å‘é€å¤±è´¥ï¼š" + (err.message || err), "err");
 }
};


btnEmoji.onclick = ()=>{
  chatInput.value += "ğŸ˜€";
  chatInput.focus();
};

btnFile.onclick = ()=> fileInput.click();

fileInput.onchange=async()=>{
 const f=fileInput.files[0];
 const buf=await f.arrayBuffer();

 try{
  await sendEncrypted(
    f.type.startsWith("image")?"image":"file",
    new Uint8Array(buf),
    {mime:f.type,name:f.name,size:f.size}
  );
 }catch(err){
  toast("å‘é€å¤±è´¥ï¼š" + (err.message || err), "err");
 }
};

function handleChatSendAck(msg){
  const key =
    msg.client_ts !== undefined ? String(msg.client_ts) :
    (msg.ts !== undefined ? String(msg.ts) : null);

  if(msg.success){
    if(key) pendingSendByTs.delete(key);
    return;
  }

  if(key) pendingSendByTs.delete(key);
  toast("å‘é€å¤±è´¥ï¼š" + (msg.error || "unknown_error"), "err");
}


async function handleIncomingMessage(msg){
  const key = sessionKeys.get(msg.from);
  if(!key) return;

  const pt = await crypto.subtle.decrypt(
    {name:"AES-GCM",iv:base64ToBytes(msg.payload.iv)},
    key,
    base64ToBytes(msg.payload.ciphertext)
  );

  renderMessage(
    msg.from,
    msg.payload.kind,
    new Uint8Array(pt),
    msg.payload,
    msg.ts
  );

}

function renderMessage(from,kind,data,meta,ts){
 const div=document.createElement("div");
 div.className="msg "+(from===session.username?"me":"peer");

 const time = (ts !== undefined && ts !== null)
   ? new Date(Number(ts))
   : null;

 if(kind==="text"){
  div.textContent=new TextDecoder().decode(data);
 }

 if(kind==="image"){
  const url=URL.createObjectURL(new Blob([data],{type:meta.mime}));
  div.innerHTML=`<img src="${url}">`;
 }

 if(kind==="file"){
  const url=URL.createObjectURL(new Blob([data],{type:meta.mime}));
  div.innerHTML=`<a href="${url}" download="${meta.name}">ğŸ“ ${meta.name}</a>`;
 }

 if(time && !isNaN(time.getTime())){
  const t = document.createElement("div");
  t.className = "muted";
  t.style.marginTop = "4px";
  t.textContent = time.toLocaleString();
  div.appendChild(t);
 }

 chatMessages.appendChild(div);
 chatMessages.scrollTop=chatMessages.scrollHeight;
}

async function loadHistory(peer){
 const r=await authedFetch(`/api/messages?peer=${peer}`);
 const j=await r.json();

 for(const m of j.messages){
  await handleIncomingMessage({
    from:m.from,
    payload:m.payload,
    ts: m.ts
  });
 }
}

async function fetchPasswordParams(){
  if(!session.httpToken) throw new Error("no http token");

  const r = await fetch(HTTP_BASE + "/api/user/password_params", {
    method: "GET",
    headers: {
      "Authorization": "Bearer " + session.httpToken
    }
  });

  if(!r.ok) throw new Error("http " + r.status);

  const j = await r.json();
  if(!j.success || !j.passwordHash)
    throw new Error("invalid response");

  return j.passwordHash; 
  // { kdf, iterations, salt }
}

function $(id){ return document.getElementById(id); }

function setStatus(msg, isErr=false){
  const el = $("status");
  el.textContent = msg;
  el.style.color = isErr ? "rgba(239,68,68,.95)" : "rgba(255,255,255,.70)";
}

function setWsState(text){
  $("wsState").textContent = text;
}

function updateWsDot(){
  const dot1 = $("wsDot");
  const dot2 = $("wsDotHome");
  const ok = wsReady;
  if(dot1){
    dot1.className = "dot " + (ok ? "ok" : "bad");
  }
  if(dot2){
    dot2.className = "dot " + (ok ? "ok" : "bad");
  }
}

function strToUint8(s){ return textEncoder.encode(s); }

function base64ToBytes(b64){
  const bin = atob(b64);
  const arr = new Uint8Array(bin.length);
  for(let i=0;i<bin.length;i++) arr[i] = bin.charCodeAt(i);
  return arr;
}
function bufToBase64(buf){
  const bytes = buf instanceof ArrayBuffer ? new Uint8Array(buf) : new Uint8Array(buf.buffer || buf);
  let bin = "";
  for (let b of bytes) bin += String.fromCharCode(b);
  return btoa(bin);
}
function getRandomBytes(n){
  const arr = new Uint8Array(n);
  crypto.getRandomValues(arr);
  return arr;
}

/* =====================================================
   UIï¼šçœ¼ç›åˆ‡æ¢
===================================================== */
(function setupEye(){
  const input = $("password");
  const eye = $("togglePw");
  eye.addEventListener("click", ()=> {
    input.type = (input.type === "password" ? "text" : "password");
  });
})();

/* =====================================================
   é“¾æ¥
===================================================== */
$("linkRegister").addEventListener("click", (e)=>{
  e.preventDefault();
  location.href = REGISTER_URL;
});
$("btnReconnect").addEventListener("click", ()=>{
  toast("æ­£åœ¨æ‰‹åŠ¨é‡è¿ WSâ€¦", "warn");
  try{ if(ws) ws.close(4000, "manual reconnect"); }catch{}
  ws = null;
  wsReady = false;
  connectWS();
});

/* =====================================================
   WebCryptoï¼šPBKDF2 æ´¾ç”Ÿ passwordHash
===================================================== */
async function derivePasswordHash(password, saltBytes, iterations){
  const baseKey = await crypto.subtle.importKey(
    "raw",
    strToUint8(password),
    { name:"PBKDF2" },
    false,
    ["deriveBits"]
  );

  const bits = await crypto.subtle.deriveBits(
    { name:"PBKDF2", salt: saltBytes, iterations, hash:"SHA-256" },
    baseKey,
    256
  );
  return new Uint8Array(bits); // 32 bytes
}

/* å¯†ç  â†’ AES-256-GCM keyï¼ˆè§£å¯†/åŠ å¯†ç§é’¥ï¼‰ */
async function deriveAesKey(password, saltBytes, iterations, usage){
  const baseKey = await crypto.subtle.importKey(
    "raw",
    strToUint8(password),
    { name:"PBKDF2" },
    false,
    ["deriveKey"]
  );
  return await crypto.subtle.deriveKey(
    { name:"PBKDF2", salt: saltBytes, iterations, hash:"SHA-256" },
    baseKey,
    { name:"AES-GCM", length:256 },
    false,
    usage
  );
}

async function decryptPrivateKey(aesKey, ivBytes, ciphertextBytes){
  const pkcs8 = await crypto.subtle.decrypt(
    { name:"AES-GCM", iv: ivBytes },
    aesKey,
    ciphertextBytes
  );
  return new Uint8Array(pkcs8);
}

async function encryptPrivateKey(aesKey, ivBytes, plainBytes){
  const ct = await crypto.subtle.encrypt(
    { name:"AES-GCM", iv: ivBytes },
    aesKey,
    plainBytes
  );
  return new Uint8Array(ct);
}

async function importPrivateKeyPkcs8(pkcs8Bytes){
  return await crypto.subtle.importKey(
    "pkcs8",
    pkcs8Bytes,
    { name:"ECDH", namedCurve:"P-256" },
    false,
    ["deriveBits","deriveKey"]
  );
}

/* =====================================================
   WebSocketï¼šè¿æ¥ / é‡è¿
===================================================== */
function connectWS(){
  if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) {
    return;
  }

  wsReady = false;
  setWsState("è¿æ¥ä¸­â€¦");
  updateWsDot();

  const currentWS = new WebSocket(WS_URL);
  ws = currentWS;

  currentWS.onopen = () => {
    if (ws !== currentWS) return;
    wsReady = true;
    setWsState("å·²è¿æ¥");
    updateWsDot();
    updateHomeBadges();
    updateConnPills();

    if (reconnectTimer) { clearTimeout(reconnectTimer); reconnectTimer = null; }
    reconnectDelay = 3000;
  };

  currentWS.onclose = () => {
    if (ws !== currentWS) return;

    wsReady = false;
    ws = null;

    setWsState("å·²æ–­å¼€");
    updateWsDot();
    updateHomeBadges();
    updateConnPills();

    if (session.username) {
      // å·²ç™»å½•æ—¶æ–­çº¿ï¼šå¼ºåˆ¶å›ç™»å½•é¡µ
      wipeSensitiveMemory();
      pendingLogin = null;
      backToLogin();
      setStatus("è¿æ¥å·²æ–­å¼€ï¼Œè¯·é‡æ–°ç™»å½•", true);
      toast("WS æ–­å¼€ï¼šè¯·é‡æ–°ç™»å½•", "err");
    }

    if (reconnectTimer) return;

    setWsState("æ–­å¼€ï¼Œé‡è¿ä¸­â€¦");
    updateWsDot();

    reconnectTimer = setTimeout(() => {
      reconnectTimer = null;
      connectWS();
      reconnectDelay = Math.min(reconnectDelay * 1.5, 30000);
    }, reconnectDelay);
  };

  currentWS.onerror = () => { /* ç»Ÿä¸€ç”± onclose å¤„ç† */ };

  currentWS.onmessage = async (ev) => {
    if (ws !== currentWS) return;

    console.log("[ws] raw", ev.data);
    let msg;
    try { msg = JSON.parse(ev.data); } catch { return; }
    console.log("[ws] parsed", msg);

    if (msg.type === "login_challenge") {
      await handleLoginChallenge(msg);
      return;
    }
    if (msg.type === "login_result") {
      await handleLoginResult(msg);
      return;
    }
    if (msg.type === "chat_send") {
      handleChatSendAck(msg);
      return;
    }
    if (msg.type === "friend_accepted") {
      await handleFriendAccepted(msg);
      return;
    }
    if (msg.type === "friend_removed") {
      handleFriendRemoved(msg);
      return;
    }
    if (msg.type === "friends_refresh") {
      await loadFriends();
      return;
    }
    // å…¶ä»–æ¶ˆæ¯
    if (msg.type === "chat_recv") {
      if (msg.from === session.username) {
        const key = (msg.client_ts !== undefined && msg.client_ts !== null)
      ? String(msg.client_ts)
      : (msg.ts !== undefined && msg.ts !== null ? String(msg.ts) : null);
    if (key && pendingSendByTs.has(key)) {
      pendingSendByTs.delete(key);
      return;
    }
  }
  handleIncomingMessage(msg);
}
if (msg.type === "friend_request") {
  toast("æ”¶åˆ°å¥½å‹è¯·æ±‚", "warn");
  await loadFriends();
}

  };
}

function closeWS(){
  if (ws) {
    try { ws.close(1000, "logout"); } catch {}
  }
  ws = null;
  wsReady = false;
  updateWsDot();
}

/* =====================================================
   ç™»å½•åè®®ï¼ˆä¸¤æ­¥ï¼‰
===================================================== */
let pendingLogin = null; // {username, password}

async function sendJson(obj){
  if (!ws || ws.readyState !== WebSocket.OPEN) {
    setStatus("WebSocket æœªè¿æ¥ï¼Œæ­£åœ¨è¿æ¥â€¦", true);
    connectWS();
    return false;
  }
  ws.send(JSON.stringify(obj));
  return true;
}

async function startLogin(username, password){
  pendingLogin = { username, password };

  const ok = await sendJson({ type:"login_start", username });
  if(ok) setStatus("è¯·æ±‚ç™»å½•å‚æ•°ä¸­â€¦");
}

async function handleLoginChallenge(msg){
  if(!pendingLogin) return;

  const { username, password } = pendingLogin;

  const saltB64 = msg?.salt ?? msg?.passwordHash?.salt;
  const iterations = Number(msg?.iterations ?? msg?.passwordHash?.iterations ?? PBKDF2_ITER_PWHASH);

  if(!saltB64){
    setStatus("æœåŠ¡å™¨æœªè¿”å› saltï¼Œæ— æ³•ç™»å½•", true);
    pendingLogin = null;
    toast("æœåŠ¡å™¨æœªè¿”å› salt", "err");
    return;
  }

  // ä¿å­˜ challenge å‚æ•°ï¼ˆåç»­æ”¹å¯†ç /æ³¨é”€ç”¨ï¼‰
  session.pwSaltB64 = saltB64;
  session.pwIterations = iterations;

  const saltBytes = base64ToBytes(saltB64);

  setStatus("è®¡ç®—å¯†ç å“ˆå¸Œä¸­â€¦");
  const pwHashBytes = await derivePasswordHash(password, saltBytes, iterations);

  await sendJson({
    type:"login",
    username,
    passwordHash:{
      kdf:"PBKDF2-HMAC-SHA256",
      iterations,
      salt: saltB64,
      hash: bufToBase64(pwHashBytes)
    }
  });

  setStatus("å‘é€ç™»å½•è¯·æ±‚ä¸­â€¦");
}

async function handleLoginResult(msg){
  if(!msg.success){
    setStatus("ç™»å½•å¤±è´¥ï¼š" + (msg.error || "æœªçŸ¥åŸå› "), true);
    toast("ç™»å½•å¤±è´¥ï¼š" + (msg.error || "æœªçŸ¥åŸå› "), "err");
    pendingLogin = null;
    return;
  }

  if(!pendingLogin){
    setStatus("ç™»å½•æˆåŠŸï¼Œä½†æœ¬åœ°ç¼ºå°‘ pendingLoginï¼ˆå¯†ç ä¸Šä¸‹æ–‡ï¼‰", true);
    toast("ç™»å½•æˆåŠŸä½†ç¼ºå°‘ pendingLogin", "warn");
    return;
  }

  const { username, password } = pendingLogin;

  if(!msg.encryptedPrivateKey || !msg.encryptedPrivateKey.salt || !msg.encryptedPrivateKey.iv || !msg.encryptedPrivateKey.ciphertext){
    setStatus("ç™»å½•æˆåŠŸï¼Œä½†æœåŠ¡å™¨æœªè¿”å›åŠ å¯†ç§é’¥å­—æ®µ", true);
    toast("ç¼ºå°‘ encryptedPrivateKey", "err");
    pendingLogin = null;
    return;
  }

  setStatus("è§£å¯†ç§é’¥ä¸­â€¦");

  const epk = msg.encryptedPrivateKey;
  const iterKey = Number(epk.iterations || PBKDF2_ITER_KEY_DEFAULT);
  const saltKeyBytes = base64ToBytes(epk.salt);
  const ivBytes = base64ToBytes(epk.iv);
  const ciphertextBytes = base64ToBytes(epk.ciphertext);

  try{
    const aesKey = await deriveAesKey(password, saltKeyBytes, iterKey, ["decrypt"]);
    const pkcs8Bytes = await decryptPrivateKey(aesKey, ivBytes, ciphertextBytes);

    // ===== ç™»å½•æˆåŠŸåï¼šå†™å…¥ session =====
    session.username = username;
    session.httpToken = msg.http_token || null;
    session.avatarUrl = msg.avatar_url || "/resources/avatars/default.png";
    session.displayName = msg.display_name || msg.displayName || "";

    session.privateKeyPkcs8Bytes = pkcs8Bytes;

    try { session.privateKeyCryptoKey = await importPrivateKeyPkcs8(pkcs8Bytes); }
    catch { session.privateKeyCryptoKey = null; }

    if (msg.publicKey && msg.publicKey.spki) {
      session.publicKeySpkiBytes = base64ToBytes(msg.publicKey.spki);
      try {
        session.publicKeyCryptoKey = await crypto.subtle.importKey(
          "spki",
          session.publicKeySpkiBytes,
          { name: "ECDH", namedCurve: "P-256" },
          true,
          []
        );
      } catch { session.publicKeyCryptoKey = null; }
    } else {
      session.publicKeySpkiBytes = null;
      session.publicKeyCryptoKey = null;
    }

    pendingLogin = null;
    setStatus("");
    toast("ç™»å½•æˆåŠŸ", "ok");
    enterHome();

  }catch(err){
    console.error(err);
    setStatus("ç§é’¥è§£å¯†å¤±è´¥ï¼š" + (err.message || err), true);
    toast("ç§é’¥è§£å¯†å¤±è´¥", "err");
    pendingLogin = null;
  }
}

/* =====================================================
   è§†å›¾åˆ‡æ¢
===================================================== */
function backToLogin(){
  $("viewHome").classList.add("hidden");
  $("viewLogin").classList.remove("hidden");
  updateHomeBadges();
  updateConnPills();
}

function enterHome(){
  $("viewLogin").classList.add("hidden");
  $("viewHome").classList.remove("hidden");

  const path = session.avatarUrl || "/resources/avatars/default.png";
  $("avatarImg").src = HTTP_BASE + path;

  $("displayName").value = session.displayName || "";

  updateHomeBadges();
  updateConnPills();
  loadFriends();

}

function updateHomeBadges(){
  if($("homeUser")) $("homeUser").textContent = "ç”¨æˆ·ï¼š" + (session.username || "-");
  if($("homeWs")) $("homeWs").textContent = "WSï¼š" + (wsReady ? "å·²è¿æ¥" : "æœªè¿æ¥");
  if($("homeKey")) $("homeKey").textContent = "ç§é’¥ï¼š" + (session.privateKeyPkcs8Bytes ? "å·²åŠ è½½(å†…å­˜)" : "æ— ");
  updateWsDot();
}

function updateConnPills(){
  if($("pillHttp")) $("pillHttp").textContent = "HTTPï¼š" + (session.httpToken ? "å·²ç™»å½•(token)" : "-");
  if($("pillWs")) $("pillWs").textContent = "WSï¼š" + (wsReady ? "å·²è¿æ¥" : "æœªè¿æ¥");
}

/* æ¸…ç†æ•æ„Ÿå†…å­˜ */
function wipeSensitiveMemory(){
  session.username = null;
  session.displayName = null;
  session.avatarUrl = null;
  session.httpToken = null;

  session.pwSaltB64 = null;
  session.pwIterations = null;

  session.publicKeySpkiBytes = null;
  session.publicKeyCryptoKey = null;

  if (session.privateKeyPkcs8Bytes) {
    try { session.privateKeyPkcs8Bytes.fill(0); } catch {}
  }
  session.privateKeyPkcs8Bytes = null;
  session.privateKeyCryptoKey = null;
}

/* =====================================================
   ç™»å½•è¡¨å•
===================================================== */
$("loginForm").addEventListener("submit", async (e)=>{
  e.preventDefault();
  setStatus("");

  const username = $("username").value.trim();
  const password = $("password").value;

  if(!username) return setStatus("ç”¨æˆ·åä¸èƒ½ä¸ºç©º", true);
  if(!password) return setStatus("å¯†ç ä¸èƒ½ä¸ºç©º", true);

  if(!wsReady){
    setStatus("WebSocket æœªè¿æ¥ï¼Œæ­£åœ¨è¿æ¥â€¦");
    connectWS();
  }

  await startLogin(username, password);
});

/* =====================================================
   é€€å‡º
===================================================== */
$("btnLogout").addEventListener("click", ()=>{
  closeWS();
  wipeSensitiveMemory();
  pendingLogin = null;

  backToLogin();
  setStatus("");
  toast("å·²é€€å‡º", "ok");

  connectWS();
});

/* =====================================================
   HTTP helper
===================================================== */
async function authedFetch(path, opt={}){
  const headers = opt.headers ? {...opt.headers} : {};
  if(session.httpToken){
    headers["Authorization"] = "Bearer " + session.httpToken;
  }
  return await fetch(HTTP_BASE + path, { ...opt, headers });
}

async function readJsonSafe(resp){
  try { return await resp.json(); } catch { return null; }
}

/* =====================================================
   Profileï¼šä¿å­˜æ˜µç§°
===================================================== */
$("btnSaveProfile").onclick = async ()=>{
  const name = ($("displayName").value || "").trim();
  $("profileHint").textContent = "";

  if(!session.httpToken){
    toast("æ²¡æœ‰ http_tokenï¼šåç«¯éœ€è¦åœ¨ login_result è¿”å› http_token", "err");
    $("profileHint").textContent = "ç¼ºå°‘ http_token";
    return;
  }

  try{
    const r = await authedFetch("/api/user/profile", {
      method: "PATCH",
      headers: { "Content-Type":"application/json" },
      body: JSON.stringify({ display_name: name })
    });

    const j = await readJsonSafe(r);

    if(!r.ok){
      toast("ä¿å­˜å¤±è´¥ï¼šHTTP " + r.status, "err");
      $("profileHint").textContent = "HTTP " + r.status;
      return;
    }
    if(!j || !j.success){
      toast("ä¿å­˜å¤±è´¥ï¼š" + ((j && j.error) ? j.error : "æœªçŸ¥é”™è¯¯"), "err");
      $("profileHint").textContent = (j && j.error) ? j.error : "æœªçŸ¥é”™è¯¯";
      return;
    }

    session.displayName = j.display_name ?? name;
    /* ===== æ–°å¢ï¼šç«‹åˆ»åŒæ­¥ UI ===== */
$("homeUser").textContent =
  "ç”¨æˆ·ï¼š" + (session.displayName || session.username);

$("displayName").value = session.displayName;
/* ============================ */

toast("æ˜µç§°å·²ä¿å­˜", "ok");
$("profileHint").textContent = "å·²ä¿å­˜";
    setTimeout(()=> $("profileHint").textContent="", 2000);

  }catch(e){
    console.error(e);
    toast("ä¿å­˜å¤±è´¥ï¼ˆç½‘ç»œ/å¼‚å¸¸ï¼‰", "err");
    $("profileHint").textContent = "å¼‚å¸¸";
  }
};

/* =====================================================
   å¤´åƒä¸Šä¼ 
===================================================== */
$("btnUploadAvatar").onclick = async ()=>{
  $("avatarHint").textContent = "";
  const f = $("avatarFile").files[0];
  if(!f) { toast("å…ˆé€‰ä¸ªå›¾ç‰‡", "warn"); return; }

  if(!session.httpToken){
    toast("æ²¡æœ‰ http_tokenï¼šå¤´åƒä¸Šä¼ éœ€è¦é‰´æƒ", "err");
    $("avatarHint").textContent = "ç¼ºå°‘ http_token";
    return;
  }

  try{
    const buf = await f.arrayBuffer();

    const r = await authedFetch("/api/avatar/upload", {
      method: "POST",
      headers: {
        "Content-Type": f.type || "application/octet-stream",
        "X-Filename": encodeURIComponent(f.name)
      },
      body: buf
    });

    if(!r.ok){
      toast("å¤´åƒä¸Šä¼ å¤±è´¥ï¼šHTTP " + r.status, "err");
      $("avatarHint").textContent = "HTTP " + r.status;
      return;
    }

    const j = await readJsonSafe(r);
    if(!j || !j.success){
      toast("å¤´åƒä¸Šä¼ å¤±è´¥ï¼š" + ((j && j.error) ? j.error : "æœªçŸ¥é”™è¯¯"), "err");
      $("avatarHint").textContent = (j && j.error) ? j.error : "æœªçŸ¥é”™è¯¯";
      return;
    }

    session.avatarUrl = j.avatar_url;
    $("avatarImg").src = HTTP_BASE + j.avatar_url + "?t=" + Date.now();
    toast("å¤´åƒå·²æ›´æ–°", "ok");
    $("avatarHint").textContent = "å·²æ›´æ–°";
    setTimeout(()=> $("avatarHint").textContent="", 2000);

  }catch(e){
    console.error(e);
    toast("å¤´åƒä¸Šä¼ å¤±è´¥ï¼ˆç½‘ç»œ/å¼‚å¸¸ï¼‰", "err");
    $("avatarHint").textContent = "å¼‚å¸¸";
  }
};

/* =====================================================
   æ”¹å¯†ç ï¼šç”Ÿæˆ newPasswordHash + newEncryptedPrivateKey
===================================================== */
document.getElementById("btnChangePassword").onclick = async ()=>{
  const oldPw = document.getElementById("oldPw").value;
  const newPw = document.getElementById("newPw").value;
  const newPw2 = document.getElementById("newPw2").value;

  if(!oldPw || !newPw || !newPw2)
    return toast("è¯·å¡«å†™å®Œæ•´", "warn");

  if(newPw !== newPw2)
    return toast("ä¸¤æ¬¡æ–°å¯†ç ä¸ä¸€è‡´", "warn");

  if(!session.privateKeyPkcs8Bytes)
    return toast("æœ¬åœ°æ²¡æœ‰ç§é’¥ï¼Œæ— æ³•æ”¹å¯†ç ", "err");

  try{
    toast("è·å–å¯†ç å‚æ•°ä¸­â€¦", "warn");

    /* 1ï¸âƒ£ è·å– password hash å‚æ•° */
    const pwParams = await fetchPasswordParams();
    const oldSaltBytes = base64ToBytes(pwParams.salt);
    const oldIter = Number(pwParams.iterations);

    /* 2ï¸âƒ£ è®¡ç®— oldPasswordHash */
    const oldHashBytes =
      await derivePasswordHash(oldPw, oldSaltBytes, oldIter);

    const oldPasswordHash = {
      kdf: pwParams.kdf,
      iterations: oldIter,
      salt: pwParams.salt,
      hash: bufToBase64(oldHashBytes)
    };

    /* 3ï¸âƒ£ ç”Ÿæˆ newPasswordHash */
    const newSaltBytes = getRandomBytes(16);
    const newSaltB64 = bufToBase64(newSaltBytes);
    const newIter = 300000; // â† ä½ å¯ä»¥åœ¨è¿™é‡Œå‡çº§å®‰å…¨å¼ºåº¦

    const newHashBytes =
      await derivePasswordHash(newPw, newSaltBytes, newIter);

    const newPasswordHash = {
      kdf: "PBKDF2-HMAC-SHA256",
      iterations: newIter,
      salt: newSaltB64,
      hash: bufToBase64(newHashBytes)
    };

    /* 4ï¸âƒ£ ç”¨æ–°å¯†ç é‡æ–°åŠ å¯†ç§é’¥ */
    const keySalt = getRandomBytes(16);
    const iv = getRandomBytes(12);

    const aesKey = await deriveAesKey(
      newPw,
      keySalt,
      PBKDF2_ITER_KEY_DEFAULT,
      ["encrypt"]
    );

    const ct = await encryptPrivateKey(
      aesKey,
      iv,
      session.privateKeyPkcs8Bytes
    );

    const newEncryptedPrivateKey = {
      kdf: "PBKDF2-HMAC-SHA256",
      iterations: PBKDF2_ITER_KEY_DEFAULT,
      salt: bufToBase64(keySalt),
      cipher: "AES-256-GCM",
      iv: bufToBase64(iv),
      ciphertext: bufToBase64(ct)
    };

    /* 5ï¸âƒ£ æäº¤ç»™æœåŠ¡å™¨ */
    toast("æäº¤æ”¹å¯†ç è¯·æ±‚â€¦", "warn");

    const r = await fetch(HTTP_BASE + "/api/user/password", {
      method: "POST",
      headers: {
        "Authorization": "Bearer " + session.httpToken,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        oldPasswordHash,
        newPasswordHash,
        newEncryptedPrivateKey
      })
    });

    const j = await r.json();
    if(!r.ok || !j.success)
      throw new Error(j?.error || "change password failed");

    toast("å¯†ç ä¿®æ”¹æˆåŠŸï¼ˆç§é’¥å·²é‡æ–°åŠ å¯†ï¼‰", "ok");

    document.getElementById("oldPw").value = "";
    document.getElementById("newPw").value = "";
    document.getElementById("newPw2").value = "";

  }catch(e){
    console.error(e);
    toast("æ”¹å¯†ç å¤±è´¥ï¼š" + e.message, "err");
  }
};


/* =====================================================
   æ³¨é”€è´¦å·
===================================================== */
$("btnDeleteAccount").onclick = async ()=>{
  $("delHint").textContent = "";

  if(!session.httpToken){
    toast("ç¼ºå°‘ http_tokenï¼šæ³¨é”€éœ€è¦é‰´æƒ", "err");
    $("delHint").textContent = "ç¼ºå°‘ http_token";
    return;
  }

  const pw = $("delPw").value;
  const confirm = ($("delConfirm").value || "").trim();

  if(!pw){
    toast("è¯·è¾“å…¥å¯†ç ç¡®è®¤", "warn");
    return;
  }
  if(confirm !== "DELETE"){
    toast("äºŒæ¬¡ç¡®è®¤éœ€è¦è¾“å…¥ DELETE", "warn");
    return;
  }

  try{
    toast("è·å–å¯†ç å‚æ•°ä¸­â€¦", "warn");
    $("delHint").textContent = "è·å–å‚æ•°â€¦";

    /* 1ï¸âƒ£ å®æ—¶è·å– password hash å‚æ•°ï¼ˆå…³é”®ä¿®æ­£ç‚¹ï¼‰ */
    const pwParams = await fetchPasswordParams();
    const iter = Number(pwParams.iterations);
    const saltBytes = base64ToBytes(pwParams.salt);

    /* 2ï¸âƒ£ è®¡ç®— passwordHash */
    const hashBytes = await derivePasswordHash(pw, saltBytes, iter);

    const passwordHash = {
      kdf: pwParams.kdf,
      iterations: iter,
      salt: pwParams.salt,
      hash: bufToBase64(hashBytes)
    };

    toast("æäº¤æ³¨é”€è¯·æ±‚â€¦", "warn");
    $("delHint").textContent = "æäº¤è¯·æ±‚â€¦";

    /* 3ï¸âƒ£ æäº¤æ³¨é”€è¯·æ±‚ */
    const r = await authedFetch("/api/user", {
      method: "DELETE",
      headers: { "Content-Type":"application/json" },
      body: JSON.stringify({ passwordHash })
    });

    const j = await readJsonSafe(r);

    if(!r.ok || !j || !j.success){
      throw new Error(j?.error || "delete account failed");
    }

    toast("è´¦å·å·²æ³¨é”€ï¼ˆæœ¬åœ°å°†é€€å‡ºï¼‰", "ok");

    /* 4ï¸âƒ£ æœ¬åœ°æ¸…ç† + å›ç™»å½•é¡µ */
    closeWS();
    wipeSensitiveMemory();
    pendingLogin = null;

    $("delPw").value = "";
    $("delConfirm").value = "";
    $("panelDelete").open = false;

    backToLogin();
    setStatus("");

    connectWS();

  }catch(e){
    console.error(e);
    toast("æ³¨é”€å¤±è´¥ï¼š" + e.message, "err");
    $("delHint").textContent = "å¤±è´¥";
  }
};
const drawer = document.getElementById("settingsDrawer");

$("btnSettings").onclick = ()=>{
  drawer.classList.remove("hidden");
};

$("btnCloseSettings").onclick = ()=>{
  drawer.classList.add("hidden");
};

drawer.querySelector(".settings-mask").onclick = ()=>{
  drawer.classList.add("hidden");
};
async function loadFriends(){
  console.log("[friends] loadFriends start", { hasToken: !!session.httpToken });
  const r = await authedFetch("/api/friends");
  console.log("[friends] response", r.status);
  const j = await readJsonSafe(r);
  console.log("[friends] body", j);

  if(!r.ok || !j.success){
    toast("å¥½å‹åˆ—è¡¨åŠ è½½å¤±è´¥", "err");
    return;
  }

  friends = j.friends || [];
  friendRequests = j.requests || [];

  // pre-derive session keys for friends with public_key.spki
  for (const f of friends) {
    if (!f.public_key || !f.public_key.spki) continue;
    if (sessionKeys.has(f.username)) continue;
    try {
      const key = await deriveSessionKey(f.public_key.spki);
      sessionKeys.set(f.username, key);
    } catch (e) {
      // ignore key derivation errors; user can retry later
    }
  }

  renderFriendList();
  renderRequestList();
}


function renderFriendList(){
  const box = document.getElementById("friendList");
  box.innerHTML = "";

  for(const f of friends){
    const div = document.createElement("div");
    div.className = "im-item";

    const avatar = HTTP_BASE + (f.avatar_url || "/resources/avatars/default.png");

    div.innerHTML = `
      <div class="row" style="gap:10px;">
        <img src="${avatar}" style="width:36px;height:36px;border-radius:50%">
        <div style="flex:1">${escapeHtml(f.display_name || f.username)}</div>
        <button class="btn ghost btn-sm">â‹®</button>
      </div>
    `;

    div.onclick = (e)=>{
      if(e.target.tagName === "BUTTON") return;
      selectFriend(f, e);
    };

    // åˆ é™¤å¥½å‹
    div.querySelector("button").onclick = ()=>{
      deleteFriend(f.username);
    };

    box.appendChild(div);
  }
}

async function deleteFriend(username){
  if(!confirm("ç¡®å®šåˆ é™¤å¥½å‹ï¼ŸèŠå¤©è®°å½•å°†ä¿ç•™åœ¨æœåŠ¡å™¨ï¼ˆå¯†æ–‡ï¼‰")) return;

  const r = await authedFetch("/api/friends", {
    method: "DELETE",
    headers: { "Content-Type":"application/json" },
    body: JSON.stringify({ username })
  });

  const j = await readJsonSafe(r);

  if(!r.ok || !j.success){
    toast(j?.error || "åˆ é™¤å¤±è´¥", "err");
    return;
  }

  sessionKeys.delete(username);

  toast("å¥½å‹å·²åˆ é™¤", "ok");
  loadFriends();

  document.querySelector(".im-main").innerHTML =
    `<div class="muted">å¥½å‹å·²åˆ é™¤</div>`;
}



function selectFriend(f,e){
 currentChat=f;

 document.querySelectorAll(".im-item").forEach(x=>x.classList.remove("active"));
 e.currentTarget.classList.add("active");

 chatMessages.innerHTML="";
 loadHistory(f.username);
}

document.getElementById("btnAddFriend").onclick = async ()=>{
  const name = prompt("è¾“å…¥å¯¹æ–¹ç”¨æˆ·å");
  if(!name) return;

  let r;
  try{
    r = await authedFetch("/api/friends/request", {
      method: "POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify({ username: name })
    });
  }catch(e){
    toast("network_error", "err");
    return;
  }

  if(!r.ok){
    toast("http_error", "err");
    return;
  }

  const data = await r.json();

  if(data.success){
    if(data.status === "accepted"){
    // å¯¹æ–¹ä¹‹å‰å·²ç»è¯·æ±‚è¿‡ â†’ ç›´æ¥æˆä¸ºå¥½å‹

      const key = await deriveSessionKey(data.public_key.spki);
      sessionKeys.set(name, key);

      toast("å·²è‡ªåŠ¨äº’åŠ ä¸ºå¥½å‹", "ok");
      loadFriends();
      return;
    }
    else if(data.status === "pending"){
      toast("å·²å‘é€å¥½å‹è¯·æ±‚", "ok");
      return;
    }
    toast(data.status || "ok", "ok");
  }else{
    toast(data.error || "unknown_error", "err");
  }
};


function renderRequestList(){
  const box = document.getElementById("requestList");
  box.innerHTML = "";

  for(const r of friendRequests){
    const div = document.createElement("div");
    div.className = "im-item";

    const avatar = HTTP_BASE + (r.avatar_url || "/resources/avatars/default.png");

    div.innerHTML = `
      <div class="row" style="gap:10px;">
        <img src="${avatar}" style="width:32px;height:32px;border-radius:50%">
        <div>${escapeHtml(r.display_name || r.username)}</div>
      </div>

      <div class="row" style="margin-top:6px;">
        <button class="btn primary btn-sm">åŒæ„</button>
        <button class="btn danger btn-sm">æ‹’ç»</button>
      </div>
    `;

    div.querySelector(".btn.primary").onclick =
      ()=>acceptFriend(r.username);

    div.querySelector(".btn.danger").onclick =
      ()=>rejectFriend(r.username);

    box.appendChild(div);
  }
}

async function deriveSessionKey(peerSpkiB64){
  const peerKey = await crypto.subtle.importKey(
    "spki",
    base64ToBytes(peerSpkiB64),
    { name:"ECDH", namedCurve:"P-256" },
    false,
    []
  );

  return await crypto.subtle.deriveKey(
    { name:"ECDH", public: peerKey },
    session.privateKeyCryptoKey,
    { name:"AES-GCM", length:256 },
    false,
    ["encrypt","decrypt"]
  );
}
async function acceptFriend(username){
  const r = await authedFetch("/api/friends/accept", {
    method: "POST",
    headers: {"Content-Type":"application/json"},
    body: JSON.stringify({ username })
  });

  const j = await readJsonSafe(r);
  if(!r.ok || !j.success){
    toast("åŒæ„å¤±è´¥", "err");
    return;
  }

  const key = await deriveSessionKey(j.public_key.spki);
  sessionKeys.set(username, key);

  toast("å¥½å‹å·²æ·»åŠ ", "ok");
  // optimistic UI update to avoid needing a manual refresh
  friendRequests = friendRequests.filter(r => r.username !== username);
  if(!friends.find(f => f.username === username)){
    const req = friendRequests.find(r => r.username === username);
    friends.unshift({
      username,
      display_name: req ? req.display_name : "",
      avatar_url: req ? req.avatar_url : "/resources/avatars/default.png",
      public_key: j.public_key
    });
  }
  renderFriendList();
  renderRequestList();
  await loadFriends();
}

async function rejectFriend(username){
  const r = await authedFetch("/api/friends/reject", {
    method: "POST",
    headers: {"Content-Type":"application/json"},
    body: JSON.stringify({ username })
  });
  const j = await readJsonSafe(r);
  if(!r.ok || !j.success){
    toast("æ‹’ç»å¤±è´¥", "err");
    return;
  }
  toast("å·²æ‹’ç»", "ok");
  loadFriends();
}

async function handleFriendAccepted(msg){
  const username = msg.username;
  if(!username) return;
  if(!friends.find(f => f.username === username)){
    friends.unshift({
      username,
      display_name: msg.display_name || "",
      avatar_url: msg.avatar_url || "/resources/avatars/default.png",
      public_key: msg.public_key
    });
  }
  if(msg.public_key && msg.public_key.spki){
    try{
      const key = await deriveSessionKey(msg.public_key.spki);
      sessionKeys.set(username, key);
    }catch{}
  }
  renderFriendList();
  renderRequestList();
  if(typeof toast === "function") toast("å·²æˆä¸ºå¥½å‹", "ok");
}

function handleFriendRemoved(msg){
  const username = msg.username;
  if(!username) return;
  const uname = String(username).toLowerCase();
  friends = friends.filter(f => String(f.username || "").toLowerCase() !== uname);
  friendRequests = friendRequests.filter(r => String(r.username || "").toLowerCase() !== uname);
  sessionKeys.delete(username);
  if(currentChat && currentChat.username === username){
    currentChat = null;
    chatMessages.innerHTML = "<div class=\"muted\">å¥½å‹å·²åˆ é™¤</div>";
  }
  renderFriendList();
  renderRequestList();
  if(typeof toast === "function") toast("å¯¹æ–¹å·²åˆ é™¤å¥½å‹", "warn");
}


/* =====================================================
   é¡µé¢åŠ è½½ï¼šè‡ªåŠ¨è¿æ¥ WS
===================================================== */
connectWS();
</script>

</body>
</html>
