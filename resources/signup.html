<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<title>æ³¨å†Œ - å®‰å…¨èŠå¤©</title>
<link rel="icon" type="image/png" href="../imags/favicon.png">
<style>
  body { font-family: sans-serif; max-width: 700px; margin: 40px auto; line-height: 1.6; }
  label { display: block; margin-top: 16px; font-weight: bold; }
  input {
    width: 100%; padding: 10px; margin-top: 6px;
    box-sizing: border-box; font-size: 15px;
  }
  button { margin-top: 20px; padding: 10px 16px; font-size: 15px; }

  .error { color: #c00; font-weight: bold; }
  .success { color: #090; font-weight: bold; }

  .pw-wrapper { position: relative; }
  .toggle-eye {
    position: absolute; right: 12px; top: 10px;
    cursor: pointer; color: #666; user-select: none;
    font-size: 18px;
  }

  #pwRules li { margin: 2px 0; }
  #pwStrength { font-weight: bold; margin-top: 6px; }
</style>
</head>
<body>

<h1>æ³¨å†Œè´¦å·</h1>

<form id="registerForm">
  <!-- ç”¨æˆ·å -->
  <label>
    ç”¨æˆ·å
    <input type="text" id="username" required autocomplete="username">
  </label>

  <!-- å¯†ç  -->
  <label>
    å¯†ç 
    <div class="pw-wrapper">
      <input type="password" id="password" required autocomplete="new-password">
      <span id="togglePw" class="toggle-eye">ğŸ‘</span>
    </div>
    <small>è‡³å°‘ <b>16 ä½</b>ï¼Œä¸”åŒ…å«å¤§å†™ã€å°å†™ã€æ•°å­—ã€ç¬¦å·ã€‚</small>

    <ul id="pwRules" style="margin-top:6px; padding-left:20px; font-size:14px; color:#444;">
      <li id="rule-length">âŒ é•¿åº¦è‡³å°‘ 16 ä½</li>
      <li id="rule-lower">âŒ éœ€è¦å°å†™å­—æ¯</li>
      <li id="rule-upper">âŒ éœ€è¦å¤§å†™å­—æ¯</li>
      <li id="rule-digit">âŒ éœ€è¦æ•°å­—</li>
      <li id="rule-symbol">âŒ éœ€è¦ç¬¦å·</li>
    </ul>

    <div id="pwStrength"></div>
  </label>

  <!-- ç¡®è®¤å¯†ç  -->
  <label>
    ç¡®è®¤å¯†ç 
    <div class="pw-wrapper">
      <input type="password" id="passwordConfirm" required autocomplete="new-password">
      <span id="togglePw2" class="toggle-eye">ğŸ‘</span>
    </div>
  </label>

  <button type="submit">æ³¨å†Œ</button>
</form>

<p id="status"></p>

<script>
/* -----------------------------------------------------
   åŸºç¡€è®¾ç½®
----------------------------------------------------- */

const MIN_PASSWORD_LENGTH = 16;
const PBKDF2_ITER_KEY = 200000;     // ç”¨äºåŠ å¯†ç§é’¥
const PBKDF2_ITER_PWHASH = 200000;  // ç”¨äºå¯†ç å“ˆå¸Œ

// ä½ çš„æœåŠ¡å™¨æ¥å£ï¼ˆè®°å¾—æ”¹ï¼‰
const API_URL = "http://42.51.13.233:8080/register";

const textEncoder = new TextEncoder();

/* -----------------------------------------------------
   å·¥å…·å‡½æ•°
----------------------------------------------------- */

function setStatus(msg, isErr=false){
  const el = document.getElementById("status");
  el.textContent = msg;
  el.className = isErr ? "error" : "success";
}

function strToUint8(s){ return textEncoder.encode(s); }

function bufToBase64(buf){
  const bytes = new Uint8Array(buf);
  let bin = "";
  for (let b of bytes) bin += String.fromCharCode(b);
  return btoa(bin);
}

function getRandomBytes(n){
  const arr = new Uint8Array(n);
  crypto.getRandomValues(arr);
  return arr;
}

/* -----------------------------------------------------
   å¯†ç å¼ºåº¦ + åˆè§„éªŒè¯
----------------------------------------------------- */

function updatePasswordIndicators(pw) {
  const ruleLength = document.getElementById("rule-length");
  const ruleLower = document.getElementById("rule-lower");
  const ruleUpper = document.getElementById("rule-upper");
  const ruleDigit = document.getElementById("rule-digit");
  const ruleSymbol = document.getElementById("rule-symbol");

  const hasLower = /[a-z]/.test(pw);
  const hasUpper = /[A-Z]/.test(pw);
  const hasDigit = /[0-9]/.test(pw);
  const hasSymbol = /[^\w\s]/.test(pw);
  const longEnough = pw.length >= MIN_PASSWORD_LENGTH;

  // æ›´æ–°æ¯é¡¹
  ruleLength.textContent = (longEnough ? "âœ”" : "âŒ") + " é•¿åº¦è‡³å°‘ 16 ä½";
  ruleLength.style.color = longEnough ? "#090" : "#c00";

  ruleLower.textContent = (hasLower ? "âœ”" : "âŒ") + " éœ€è¦å°å†™å­—æ¯";
  ruleLower.style.color = hasLower ? "#090" : "#c00";

  ruleUpper.textContent = (hasUpper ? "âœ”" : "âŒ") + " éœ€è¦å¤§å†™å­—æ¯";
  ruleUpper.style.color = hasUpper ? "#090" : "#c00";

  ruleDigit.textContent = (hasDigit ? "âœ”" : "âŒ") + " éœ€è¦æ•°å­—";
  ruleDigit.style.color = hasDigit ? "#090" : "#c00";

  ruleSymbol.textContent = (hasSymbol ? "âœ”" : "âŒ") + " éœ€è¦ç¬¦å·";
  ruleSymbol.style.color = hasSymbol ? "#090" : "#c00";

  // è®¡ç®—å¼ºåº¦
  let score = 0;
  if (longEnough) score++;
  if (hasLower) score++;
  if (hasUpper) score++;
  if (hasDigit) score++;
  if (hasSymbol) score++;

  const strength = document.getElementById("pwStrength");
  const levels = ["æå¼±", "å¼±", "ä¸€èˆ¬", "å¼º", "éå¸¸å¼º"];
  const colors = ["#c00", "#f60", "#cc0", "#6c0", "#090"];

  strength.textContent = "å¯†ç å¼ºåº¦ï¼š" + levels[Math.min(score,4)];
  strength.style.color  = colors[Math.min(score,4)];
}

document.getElementById("password").addEventListener("input", e=>{
  updatePasswordIndicators(e.target.value);
});

/* æäº¤å‰æ ¡éªŒ */
function validatePassword(pw){
  if (pw.length < MIN_PASSWORD_LENGTH) return "å¯†ç è‡³å°‘ 16 ä½";
  if (!/[a-z]/.test(pw)) return "ç¼ºå°å†™å­—æ¯";
  if (!/[A-Z]/.test(pw)) return "ç¼ºå¤§å†™å­—æ¯";
  if (!/[0-9]/.test(pw)) return "ç¼ºæ•°å­—";
  if (!/[^\w\s]/.test(pw)) return "ç¼ºç¬¦å·";
  return null;
}

/* -----------------------------------------------------
   å¯†ç å¯è§†åˆ‡æ¢ï¼ˆçœ¼ç›ï¼‰
----------------------------------------------------- */

function setupEyeToggle(inputId, eyeId){
  const input = document.getElementById(inputId);
  const eye = document.getElementById(eyeId);
  eye.addEventListener("click", ()=>{
    input.type = (input.type === "password" ? "text" : "password");
  });
}
setupEyeToggle("password", "togglePw");
setupEyeToggle("passwordConfirm", "togglePw2");

/* -----------------------------------------------------
   WebCryptoï¼šå¯†é’¥ç”Ÿæˆã€KDFã€åŠ å¯†
----------------------------------------------------- */

// ECC å¯†é’¥å¯¹
async function generateEcKeyPair(){
  return await crypto.subtle.generateKey(
    { name:"ECDH", namedCurve:"P-256" },
    true,
    ["deriveBits", "deriveKey"]
  );
}

// KDF #1ï¼šå¯†ç  â†’ AES å¯†é’¥ï¼ˆåŠ å¯†ç§é’¥ï¼‰
async function deriveAesKey(password, salt){
  const baseKey = await crypto.subtle.importKey(
    "raw", strToUint8(password),
    { name:"PBKDF2" }, false,
    ["deriveKey"]
  );

  return await crypto.subtle.deriveKey(
    {
      name:"PBKDF2",
      salt,
      iterations: PBKDF2_ITER_KEY,
      hash:"SHA-256"
    },
    baseKey,
    { name:"AES-GCM", length:256 },
    false,
    ["encrypt","decrypt"]
  );
}

// åŠ å¯†ç§é’¥
async function encryptPrivateKey(aesKey, pkBytes){
  const iv = getRandomBytes(12);
  const ciphertext = await crypto.subtle.encrypt(
    { name:"AES-GCM", iv },
    aesKey,
    pkBytes
  );
  return { iv, ciphertext };
}

// KDF #2ï¼šå¯†ç  â†’ å¯†ç å“ˆå¸Œï¼ˆå‘ç»™æœåŠ¡å™¨ï¼‰
async function derivePasswordHash(password, salt){
  const baseKey = await crypto.subtle.importKey(
    "raw", strToUint8(password),
    { name:"PBKDF2" }, false,
    ["deriveBits"]
  );

  return new Uint8Array(
    await crypto.subtle.deriveBits(
      {
        name:"PBKDF2",
        salt,
        iterations: PBKDF2_ITER_PWHASH,
        hash:"SHA-256"
      },
      baseKey,
      256
    )
  );
}

/* -----------------------------------------------------
   è¡¨å•æäº¤ï¼šæœ€ç»ˆæ³¨å†Œé€»è¾‘
----------------------------------------------------- */

document.getElementById("registerForm").addEventListener("submit", async (e)=>{
  e.preventDefault();
  setStatus("");

  const username = document.getElementById("username").value.trim();
  const pw       = document.getElementById("password").value;
  const pw2      = document.getElementById("passwordConfirm").value;

  if (!username) return setStatus("ç”¨æˆ·åä¸èƒ½ä¸ºç©º", true);
  if (pw !== pw2) return setStatus("ä¸¤æ¬¡å¯†ç ä¸ä¸€è‡´", true);

  const err = validatePassword(pw);
  if (err) return setStatus("å¯†ç ä¸åˆè§„ï¼š" + err, true);

  try {
    setStatus("ç”Ÿæˆå¯†é’¥å¯¹ä¸­...");

    // 1. ECC å¯†é’¥å¯¹
    const kp = await generateEcKeyPair();
    const spki  = await crypto.subtle.exportKey("spki", kp.publicKey);
    const pkcs8 = await crypto.subtle.exportKey("pkcs8", kp.privateKey);

    // 2. ç”¨å¯†ç æ´¾ç”Ÿ AES å¯†é’¥ï¼ŒåŠ å¯†ç§é’¥
    const saltKey = getRandomBytes(16);
    const aesKey = await deriveAesKey(pw, saltKey);
    const enc = await encryptPrivateKey(aesKey, pkcs8);

    // 3. å¯†ç å“ˆå¸Œï¼ˆä»…å‘å“ˆå¸Œï¼‰
    const saltPw = getRandomBytes(16);
    const pwHash = await derivePasswordHash(pw, saltPw);

    // 4. æ„é€ æ³¨å†ŒåŒ…
    const payload = {
      username,

      passwordHash:{
        kdf:"PBKDF2-HMAC-SHA256",
        iterations: PBKDF2_ITER_PWHASH,
        salt: bufToBase64(saltPw),
        hash: bufToBase64(pwHash.buffer)
      },

      publicKey:{
        alg:"ECDH",
        curve:"P-256",
        spki: bufToBase64(spki)
      },

      encryptedPrivateKey:{
        kdf:"PBKDF2-HMAC-SHA256",
        iterations: PBKDF2_ITER_KEY,
        salt: bufToBase64(saltKey),
        cipher:"AES-256-GCM",
        iv: bufToBase64(enc.iv),
        ciphertext: bufToBase64(enc.ciphertext)
      }
    };

    setStatus("å‘é€æ³¨å†Œè¯·æ±‚ä¸­...");

    const resp = await fetch(API_URL, {
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify(payload)
    });

    let result;
    try { result = await resp.json(); }
    catch { return setStatus("æœåŠ¡å™¨è¿”å›ä¸æ˜¯ JSON", true); }

    if (result.success) setStatus("æ³¨å†ŒæˆåŠŸï¼");
    else setStatus("æ³¨å†Œå¤±è´¥ï¼š" + (result.error || "æœªçŸ¥åŸå› "), true);

  } catch(err){
    console.error(err);
    setStatus("æ³¨å†Œå‡ºé”™ï¼š" + err.message, true);
  }
});
</script>

</body>
</html>

